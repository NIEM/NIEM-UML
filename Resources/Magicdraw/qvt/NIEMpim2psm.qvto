import NIEMplatformBinding;
modeltype UML uses 'http://www.omg.org/spec/UML/20131001';

transformation NIEMpim2psm(inout niemUml:UML)
	extends NIEMplatformBinding;

	main() {
		pim2psmMain();
	}

property psmModel:UML::Package=null;
property mpdComponent:UML::InstanceSpecification=null;
property psmRoot:UML::Model=null;

helper pim2psmMain(){
		var topRoot:UML::Model:=niemUml.rootObjects()
			->select(m|m.oclIsKindOf(UML::Model))
			.oclAsType(UML::Model)->asSequence()->first();

		psmRoot:=topRoot.nestedPackage
			->select(p|p.name='PSM').oclAsType(UML::Model)->asSequence()->first();
		if(psmRoot.oclIsUndefined().not())then psmRoot.removeElement() endif;
		psmRoot:=new UML::Model@niemUml();
		psmRoot.name:='PSM';
		topRoot.oclAsType(UML::Model).initializeProfileGlobals();

		var allPimMpds:Set(UML::InstanceSpecification)=topRoot.allSubobjectsOfType(UML::InstanceSpecification).oclAsType(UML::InstanceSpecification)
			->select(c|
				c.classifier->includes(prompdStereotype)
				and c.isEditable()
				)->asSet();
		// gather all pim schemas, then use to create psm schemas, then types
		// create psm schemas first, then types otherwise stack overflow may occur
		var allPimSchemas:Set(UML::Package)=allPimMpds.gatherAllPimSchemas()->asSet();
		isFirstComponent:=true;
		allPimMpds.map ModelPackageDescription_Model(psmRoot,null);
		topRoot.packagedElement+=psmRoot;
	return;
}

helper  UML::InstanceSpecification::gatherAllPimSchemas():Set(UML::Package){
	gatherAllPimSchemas:=Set{};
	self.getPimInformationModels().gatherAllPimSchemas();	
	return 	gatherAllPimSchemas;
	}
property gatherAllPimSchemas:Set(UML::Package)=Set{};
property suppressPsmSchemaTypeMap:Boolean=false;
property isFirstComponent:Boolean=false;
property constraintMode:Boolean=false;

helper  UML::Package::gatherAllPimSchemas(){
	if(gatherAllPimSchemas->includes(self))then{return;}endif;
        if(self.name=XMLPrimitiveTypesPackageName)then{return ;}endif;
        if(self.name=UMLPrimitiveTypesPackageName)then{return ;}endif;
	
		gatherAllPimSchemas+=self;
		self.ownedType
			->select(t|t.oclIsKindOf(UML::Classifier)).oclAsType(UML::Classifier)
			->forEach(c){
				// pick up general, property types
               c.general.getPimClassifier(self).getNearestNIEMSchemaPackage().gatherAllPimSchemas();
               c.attribute
               	->select(a|
               		not(a.type.oclIsUndefined()) 
               		and a.type.oclIsKindOf(UML::Classifier)
               		).type.oclAsType(UML::Classifier)
               	.getPimClassifier(self).getNearestNIEMSchemaPackage().gatherAllPimSchemas();
                                
			};
	return;
	}

////////////////////////////////////mappings
////////////////////////////////////disjunction mappings
mapping UML::Element::AbstractXSDFeature(inout psmOwner:UML::Element,domainContext:UML::Package):UML::Property@niemUml
	disjuncts
	UML::Generalization::NIEMRoleOf_generalization,
	UML::Generalization::NIEMProperty_augmentation,
	UML::Property::NIEMAnyProperty,
	UML::Property::NIEMProperty_associationClassEnd,
	UML::Property::NIEMRoleOf,
	UML::Property::NIEMProperty
	{}
mapping UML::Generalization::AbstractBaseTypeDefinition(inout psmOwner:UML::Classifier,domainContext:UML::Package):UML::Element@niemUml
	disjuncts
	UML::Generalization::NIEMTopLevel_generalization,
	UML::Generalization::NIEMSimpleContent,
	UML::Generalization::NIEMSimpleRestriction,
	UML::Generalization::NIEMExtension
	{}
mapping UML::Package::AbstractPackage(inout psmContainer:UML::Package,domainContext:UML::Package):UML::Package@niemUml
	disjuncts
	UML::Package::NIEMNamespace,
	UML::Package::MpdFolderType
	{}
mapping UML::Type::AbstractXSDTypeDefinition(inout psmOwner:UML::Element,domainContext:UML::Package):UML::Classifier@niemUml
	disjuncts
	UML::Class::AbstractNIEMComplexType,
	UML::DataType::AbstractXSDTypeDefinition_datatype
	{}
mapping UML::Class::AbstractNIEMComplexType(inout psmOwner:UML::Element,domainContext:UML::Package):UML::Class@niemUml
	disjuncts
	UML::AssociationClass::AssociationType_associationClass,
	UML::Class::TopLevel,
	UML::Class::AugmentationType_class,
	UML::Class::AdapterType_class,
	UML::Class::AssociationType_class,
	UML::Class::MetadataType_class,
	UML::Class::ObjectType_class
	{}
mapping UML::DataType::AbstractXSDTypeDefinition_datatype(inout psmOwner:UML::Element,domainContext:UML::Package):UML::Classifier@niemUml
	disjuncts
	UML::Enumeration::NIEMLocalVocabulary,
	UML::Enumeration::NIEMMergedType_enumeration,
	UML::Enumeration::NIEMSimpleType_enumeration,
	UML::Enumeration::NIEMComplexType_enumeration,
	UML::DataType::NIEMSimpleType_list,
	UML::DataType::NIEMSimpleType_union,
	UML::PrimitiveType::NIEMSimpleType_primitive,
	UML::DataType::NIEMSimpleType,
	UML::DataType::NIEMComplexType_datatype,
	UML::DataType::ObjectType_datatype
	{}
mapping UML::Dependency::AbstractReference(inout psmOwner:UML::NamedElement,domainContext:UML::Package):UML::Dependency@niemUml
	disjuncts UML::Realization::Reference
	{}
mapping UML::DirectedRelationship::AbstractModelPackageDescriptionFile(
	inout psmOwner:UML::PackageableElement,
	psmNiemNamespace:UML::Namespace
	)
	:UML::DirectedRelationship@niemUml
	disjuncts 
		UML::Usage::RelaxNGSchema,
		UML::Usage::XMLCatalog,
		UML::Usage::SchematronSchema,
		UML::Usage::ApplicationInfo,
		UML::Usage::Wantlist,
		UML::Usage::MPDChangeLog,
		UML::Usage::ReadMe,
		UML::Usage::Documentation,
		UML::Usage::File,
		UML::Usage::ConformanceReport,
		UML::Usage::ConformanceAssertion,
		UML::Usage::BusinessRulesArtifact,
		UML::Usage::IEPSampleXMLDocument,
		UML::Usage::RequiredFile,
		UML::Usage::ExternalSchemaDocument,
		UML::Usage::SubsetSchemaDocument,
		UML::Usage::ExtensionSchemaDocument,
		UML::Usage::ReferenceSchemaDocument,
		UML::Usage::FileType
	{}
mapping UML::Dependency::AbstractTypeDefinition(
	inout psmOwner:UML::DataType,domainContext:UML::Package):UML::Dependency@niemUml
	disjuncts
	UML::Usage::UnionOf,
	UML::Realization::TypeDefinition
	{}

/////////////////////////////////executable mappings
mapping UML::Element::Description(pimBody:String,inout psmElement:UML::Element):UML::Comment@niemUml{
	init{}
	var psmBody:String=self.standardOpeningPhrase(psmElement,pimBody).toCharSet('UTF-8');
	if((psmBody=null) or (psmBody=''))then{psmBody:='(UNDOCUMENTED)';}else{}endif;
	body:=psmBody;
	annotatedElement:=psmElement;
	psmElement.ownedComment+=result;
	result.ApplyStereotype(NIEMDescriptionStereotype);
}
// comment refinement
query UML::Element::getPimComment():UML::Comment=
	self.ownedComment->select(c|c.IsStereotypeApplied(NIEMDescriptionStereotype))->asSequence()
		->union(self.ownedComment->select(c|not(c.body.oclIsUndefined())and(c.body<>''))->asSequence())->first();

mapping UML::Element::XSDComponent(inout psmOwner:UML::Element,domainContext:UML::Package):UML::Element@niemUml{
	init{}
	self.getPimComment()
		->forEach(comment){self.map Description(comment.body,result);};
	if(self.stereotypedBy('Deprecated'))then{
		result.ApplyStereotype(NIEMDeprecatedStereotype);
	}endif;	
}
mapping UML::Realization::Reference(inout psmOwner:UML::NamedElement,domainContext:UML::Package):UML::Realization@niemUml
	inherits UML::NamedElement::XSDNamedComponent
	when{self.isValidReference()}
{
	init{}
	psmOwner.getNearestPackage().packagedElement+=result;
	result.ApplyStereotype(NIEMReferencesStereotype);
	client+=psmOwner;
	self.supplier->forEach(namedElement){
		// in case of Property to Property in a non <<PropertyHolder>>, attempt to resolve to a <<PropertyHolder>>
		if(psmOwner.oclIsKindOf(UML::Property)
			and namedElement.oclIsKindOf(UML::Property)
			and not(namedElement.namespace.IsStereotypeApplied(NIEMPropertyHolderStereotype))
			// make sure that this is not a subsetting <<References>>
				and not(self.isSubbsettingReference(namedElement))
			)then{
			// make sure this is in a <<PropertyHolder>>
			// see if we can indirectly resolve via non-<<PropertyHolder>>
			var referencedPSMNonTopLevelProperty:UML::NamedElement=namedElement.toPsmNamedElement(domainContext);
			if(not(referencedPSMNonTopLevelProperty.oclIsUndefined()))then{
				referencedPSMNonTopLevelProperty.clientDependency.supplier
					->select(p|p.oclIsKindOf(UML::Property) and p.namespace.IsStereotypeApplied(NIEMPropertyHolderStereotype))
					->forEach(topLevelProperty){
						supplier+=topLevelProperty;
					};
			}endif;
			// if still not found, make the top level property and hook up
			if(result.supplier->isEmpty())then{
				var referencedPSMTopLevelProperty:UML::Property=
					namedElement.oclAsType(UML::Property).makeTopLevelPSMProperty(psmOwner.oclAsType(UML::Property),domainContext);
				supplier:=referencedPSMTopLevelProperty;
			}endif;
			// if we could not find it, then back to original
			if(result.supplier->isEmpty())then{
				supplier+=namedElement.toPsmNamedElement(domainContext);
			}endif;
		}else{
			supplier+=namedElement.toPsmNamedElement(domainContext);
		}endif;
	};	
	
	
}
mapping UML::NamedElement::XSDNamedComponent(inout psmOwner:UML::Element,domainContext:UML::Package):UML::NamedElement@niemUml
	inherits UML::Element::XSDComponent
{
	init{}
	name:=self.getBaseNiemName();
}
mapping UML::NamedElement::Package_init(inout psmOwner:UML::Package,domainContext:UML::Package):UML::PackageableElement@niemUml
	inherits UML::NamedElement::XSDNamedComponent
{
	init{
		psmOwner.packagedElement+=result;
	}
	// propagate any References
	self.clientDependency.map AbstractReference(result,domainContext);
}
helper UML::Package::mapMpdFolderType(inout psmOwner:UML::Package,domainContext:UML::Package,inout resultOverride:UML::Package)
{
	// allow this helper to be overridden
	return;
}

mapping UML::Package::MpdFolderType(inout psmOwner:UML::Package,domainContext:UML::Package):UML::Package@niemUml
	inherits UML::NamedElement::Package_init

{
	self.mapMpdFolderType(psmOwner,domainContext,result);
	
}
mapping UML::Package::NIEMNamespace(inout psmOwner:UML::Package,domainContext:UML::Package):UML::Package@niemUml
	inherits UML::NamedElement::Package_init
	when{self.isNIEMNamespace()}
{
	var pimStereotypeInstance:Stdlib::Element=self.GetStereotypeApplication(NIEMInformationModelStereotype).oclAsType(Stdlib::Element);
	var purposeCode:String='extension';
	if(self.IsStereotypeApplied(NIEMInformationModelStereotype))then{
		purposeCode:=self.GetStereotypeApplication(NIEMInformationModelStereotype).oclAsType(Stdlib::Element).getInformationModelDefaultPurpose();
		if(purposeCode='reference')then {purposeCode:='subset';}endif;
		if(purposeCode.oclIsUndefined() or (purposeCode=''))then {purposeCode:='extension';}endif;
	}endif;
	if(constraintMode)then{purposeCode:='constraint';}endif;
	if(not(pimStereotypeInstance.getPimSchemaConformantIndicator()))then{purposeCode:='external';}endif;
	if(self.supplierDependency
		->select(d|
			d.stereotypedBy('ReferenceSchemaDocument')
			or d.stereotypedBy('SubsetSchemaDocument')
			or d.stereotypedBy('ExtensionSchemaDocument')
			or d.stereotypedBy('ExternalSchemaDocument')
			)->isEmpty())then{// if a Usage does not already exist
			var mpdFileType:UML::Usage=new UML::Usage@niemUml();
			var fileType:UML::InstanceSpecification=mpdComponent;
			mpdFileType.client+=fileType;
			mpdComponent.getNearestPackage().packagedElement+=mpdFileType;
			mpdFileType.supplier+=result;
			var schemaDocumentStereotypeInstance:Stdlib::Element=null;
			// apply stereotype
			if(purposeCode='reference')then {
				schemaDocumentStereotypeInstance:=mpdFileType.ApplyStereotype(NIEMReferenceSchemaDocument);
			}endif;
			if(purposeCode='subset')then {
				schemaDocumentStereotypeInstance:=mpdFileType.ApplyStereotype(NIEMSubsetSchemaDocument);
			}endif;
			if(purposeCode='extension')then {
				schemaDocumentStereotypeInstance:=mpdFileType.ApplyStereotype(NIEMExtensionSchemaDocument);
			}endif;
			if(purposeCode='external')then {
				schemaDocumentStereotypeInstance:=mpdFileType.ApplyStereotype(NIEMExternalSchemaDocument);
			}endif;
		
			if(not(schemaDocumentStereotypeInstance.oclIsUndefined()))then{
				result.getPimComment()
				.body->forEach(body){schemaDocumentStereotypeInstance.setDescriptionText(body);};
				}endif;
		}endif;
	switch{
		case(self.IsStereotypeApplied(NIEMInformationModelStereotype)){
			var stereotypeInstance:Stdlib::Element=result.ApplyStereotype(NIEMSchemaStereotype);
			pimStereotypeInstance.cloneInformationModelToNamespace(stereotypeInstance);
		};
		case(self.IsStereotypeApplied(NIEMSchemaStereotype)){
			pimStereotypeInstance:=self.GetStereotypeApplication(NIEMSchemaStereotype).oclAsType(Stdlib::Element);
			pimStereotypeInstance.deepcloneStereotypeApplication(NIEMSchemaStereotype,result);
			};
		else{
			/// should not happen
			log('ERROR: not a NIEM Namespace '+self.qualifiedName);
		};
    };
	// for reference schemas: ownedType on demand, except explicit elementImport
	if(not(suppressPsmSchemaTypeMap))then{
		if(purposeCode<>'reference')then {self.ownedType.map AbstractXSDTypeDefinition(result,domainContext);}endif;
	}endif;
	// attributeGroupDefinitions
	self.nestedPackage.map AttributeGroupDefinitions(result,domainContext);
}
mapping UML::Element::AbstractArtifactOrArtifactSet():UML::NamedElement@niemUml
	disjuncts
		UML::InstanceSpecification::FileSet,
		UML::InstanceSpecification::SchemaDocumentSet,
		UML::InstanceSpecification::ConstraintSchemaDocumentSet,
		UML::InstanceSpecification::EXIXMLSchemaType
{
}
mapping UML::Element::ArtifactOrArtifactSet():UML::InstanceSpecification@niemUml
{
}
mapping UML::InstanceSpecification::DescribedType():UML::InstanceSpecification@niemUml
{
	result.setDescriptionText(self.getDescriptionText());
}
mapping UML::InstanceSpecification::FileSetType():UML::InstanceSpecification@niemUml
	inherits UML::InstanceSpecification::DescribedType
{
	result.setExternalURI(self.getExternalURI());
	result.setPathURI(self.getPathURI());
    self.clientDependency->forEach(pimDependency){
    			pimDependency.supplier->select(s|s.oclIsKindOf(UML::Package)).oclAsType(UML::Package)->forEach(psmPackage){
   					pimDependency.map AbstractModelPackageDescriptionFile(mpdComponent,psmPackage);
   				};
   			};
    self.getArtifactOrArtifactSetList().value
    	->select(v|v.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance->forEach(artifact){
    	artifact.map AbstractArtifactOrArtifactSet();
	};
	
}
mapping UML::InstanceSpecification::FileSet():UML::InstanceSpecification@niemUml
	inherits UML::InstanceSpecification::FileSetType
	when{self.classifier.name->includes('FileSet')}
{
		'FileSet'.setInstanceClassifier(result);
}


mapping UML::InstanceSpecification::SchemaDocumentSet():UML::InstanceSpecification@niemUml
	inherits UML::InstanceSpecification::FileSetType
	when{self.classifier.name->includes('SchemaDocumentSet')}
{
		'SchemaDocumentSet'.setInstanceClassifier(result);
}
mapping UML::InstanceSpecification::SchemaDocumentSetType():UML::InstanceSpecification@niemUml
	inherits UML::InstanceSpecification::FileSetType
{
}

mapping UML::InstanceSpecification::ConstraintSchemaDocumentSet():UML::InstanceSpecification@niemUml
	inherits UML::InstanceSpecification::SchemaDocumentSetType
	when{self.classifier.name->includes('ConstraintSchemaDocumentSet')}
{
		'ConstraintSchemaDocumentSet'.setInstanceClassifier(result);
}
mapping UML::Usage::FileType(inout psmOwner:UML::PackageableElement,inout psmNiemNamespace:UML::Namespace):UML::Usage@niemUml
	inherits UML::Usage::ModelPackageDescriptionFile
	when{self.stereotypedBy('FileType')}
	
{
}
mapping UML::Usage::ConformanceReport(inout psmOwner:UML::InstanceSpecification,inout psmNiemNamespace:UML::Namespace):UML::Usage@niemUml
	inherits UML::Usage::ModelPackageDescriptionFile
	when{self.stereotypedBy('ConformanceReport')}
{
		self.ApplyFileTypeStereotype(NIEMConformanceReport,result);
}

mapping UML::InstanceSpecification::ValidityConstraintWithContextType():UML::InstanceSpecification@niemUml
	inherits UML::InstanceSpecification::DescribedType
{
}
mapping UML::InstanceSpecification::ValidityConstraintType():UML::InstanceSpecification@niemUml
	inherits UML::InstanceSpecification::ValidityConstraintWithContextType
{
}

mapping UML::InstanceSpecification::XMLSchemaType():UML::InstanceSpecification@niemUml
	inherits UML::InstanceSpecification::ValidityConstraintType
{
}
mapping UML::InstanceSpecification::EXIXMLSchemaType():UML::InstanceSpecification@niemUml
	inherits UML::InstanceSpecification::XMLSchemaType
	when{self.classifier.name->includes('EXIXMLSchemaType')}
{
		
}

mapping UML::Usage::RelaxNGSchema(inout psmOwner:UML::InstanceSpecification,inout psmNiemNamespace:UML::Namespace):UML::Usage@niemUml
	inherits UML::Usage::ModelPackageDescriptionFile
	when{self.stereotypedBy('RelaxNGSchema')}
{
		self.ApplyFileTypeStereotype(NIEMRelaxNGSchema,result);
}
mapping UML::Usage::XMLCatalog(inout psmOwner:UML::InstanceSpecification,inout psmNiemNamespace:UML::Namespace):UML::Usage@niemUml
	inherits UML::Usage::ModelPackageDescriptionFile
	when{self.stereotypedBy('XMLCatalog')}
{
		self.ApplyFileTypeStereotype(NIEMXMLCatalog,result);
}

mapping UML::Usage::SchematronSchema(inout psmOwner:UML::InstanceSpecification,inout psmNiemNamespace:UML::Namespace):UML::Usage@niemUml
	inherits UML::Usage::ModelPackageDescriptionFile
	when{self.stereotypedBy('SchematronSchema')}
{
		self.ApplyFileTypeStereotype(NIEMSchematronSchema,result);
}
mapping UML::Usage::ApplicationInfo(inout psmOwner:UML::InstanceSpecification,inout psmNiemNamespace:UML::Namespace):UML::Usage@niemUml
	inherits UML::Usage::ModelPackageDescriptionFile
	when{self.stereotypedBy('ApplicationInfo')}
{
		self.ApplyFileTypeStereotype(NIEMApplicationInfo,result);
}
mapping UML::Usage::Wantlist(inout psmOwner:UML::InstanceSpecification,inout psmNiemNamespace:UML::Namespace):UML::Usage@niemUml
	inherits UML::Usage::ModelPackageDescriptionFile
	when{self.stereotypedBy('Wantlist')}
{
		self.ApplyFileTypeStereotype(NIEMWantlist,result);
}

mapping UML::Usage::MPDChangeLog(inout psmOwner:UML::InstanceSpecification,inout psmNiemNamespace:UML::Namespace):UML::Usage@niemUml
	inherits UML::Usage::ModelPackageDescriptionFile
	when{self.stereotypedBy('MPDChangeLog')}
{
		self.ApplyFileTypeStereotype(NIEMMPDChangeLog,result);
}

mapping UML::Dependency::ModelPackageDescriptionRelationship(inout psmClient:UML::InstanceSpecification):UML::Dependency@niemUml
	when{self.stereotypedBy('ModelPackageDescriptionRelationship')}
{
		client+=psmClient;
		supplier+=self.supplier;
		psmClient.getNearestPackage().packagedElement+=result;
		var appliedSourceInstance:Stdlib::Element=self.GetStereotypeApplication(NIEMModelPackageDescriptionRelationshipStereotype);
		var appliedTargetInstance:Stdlib::Element=result.ApplyStereotype(NIEMModelPackageDescriptionRelationshipStereotype);
		appliedTargetInstance.setDescriptionText(appliedSourceInstance.getDescriptionText());
		appliedTargetInstance.setRelationshipCode(appliedSourceInstance.getRelationshipCode());
		
}
helper UML::Package::addPackage(name:String):UML::Package{
	var inPackage:UML::Package=self;
	var baseXsdPackage:UML::Package=self.nestedPackage->select(base|base.name=name)->asSequence()->first();
	if(baseXsdPackage.oclIsUndefined())then{
		baseXsdPackage:=new UML::Package@niemUml();
		baseXsdPackage.name:=name;
		inPackage.packagedElement+=baseXsdPackage;
	}endif;
	return baseXsdPackage;
}
helper UML::InstanceSpecification::ImplicitMPDR(inout mpdr:UML::Usage,conformanceURI:String,packageName:String){
	mpdr.client+=self;
	var basePackage:UML::Package=self.getNearestPackage();
	basePackage.packagedElement+=mpdr;
	var placeHolderPackage:UML::Package=basePackage.addPackage(packageName);
	placeHolderPackage.URI:=conformanceURI;
	mpdr.supplier+=placeHolderPackage;
	var appliedTargetInstance:Stdlib::Element=mpdr.ApplyStereotype(NIEMModelPackageDescriptionRelationshipStereotype);
	appliedTargetInstance.setRelationshipCode('conforms-to');
	return;
}
mapping inout UML::InstanceSpecification::ImplicitMPDRndr():UML::Usage@niemUml
{
	self.ImplicitMPDR(result,'http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/','NIEM NDR 3.0');
}
mapping inout UML::InstanceSpecification::ImplicitMPDRmpd():UML::Usage@niemUml
{
	self.ImplicitMPDR(result,'http://reference.niem.gov/niem/specification/model-package-description/3.0/','NIEM MPD Specification 3.0');
}
mapping inout UML::InstanceSpecification::ImplicitMPDRtargetAttributes():UML::Usage@niemUml
{
	self.ImplicitMPDR(result,'http://reference.niem.gov/niem/specification/conformance-targets-attribute/3.0/','NIEM Conformance Targets Attribute Specification 3.0');
}
mapping inout UML::InstanceSpecification::ImplicitMPDRconformance():UML::Usage@niemUml
{
	self.ImplicitMPDR(result,'http://reference.niem.gov/niem/specification/conformance/3.0/','NIEM Conformance 3.0');
}

mapping inout UML::InstanceSpecification::ImplicitOasisCatalog():UML::Usage@niemUml
{
	client+=self;
	var basePackage:UML::Package=self.getNearestPackage();
	basePackage.packagedElement+=result;
	var baseXsdPackage:UML::Package=basePackage.addPackage('base-xsd');
	var placeHolderPackage:UML::Package=baseXsdPackage.addPackage('xml-catalog.xml');
	supplier+=placeHolderPackage;
	result.ApplyStereotype(NIEMXMLCatalog);
}
mapping inout UML::InstanceSpecification::ImplicitWantlist():UML::Usage@niemUml
{
	client+=self;
	var basePackage:UML::Package=self.getNearestPackage();
	basePackage.packagedElement+=result;
	var baseXsdPackage:UML::Package=basePackage.addPackage('base-xsd');
	var niemPackage:UML::Package=baseXsdPackage.addPackage('niem');
	var placeHolderPackage:UML::Package=niemPackage.addPackage('wantlist.xml');
	supplier+=placeHolderPackage;
	result.ApplyStereotype(NIEMWantlist);
}
mapping inout UML::InstanceSpecification::ImplicitConformanceReport():UML::Usage@niemUml
{
	client+=self;
	var basePackage:UML::Package=self.getNearestPackage();
	basePackage.packagedElement+=result;
	var placeHolderPackage:UML::Package=basePackage.addPackage('conformance-report.html');
	supplier+=placeHolderPackage;
	result.ApplyStereotype(NIEMConformanceReport);
}
mapping inout UML::InstanceSpecification::ImplicitConformanceAssertion():UML::Usage@niemUml
{
	client+=self;
	var basePackage:UML::Package=self.getNearestPackage();
	basePackage.packagedElement+=result;
	var placeHolderPackage:UML::Package=basePackage.addPackage('conformance-assertion.html');
	supplier+=placeHolderPackage;
	result.ApplyStereotype(NIEMConformanceAssertion);
}
mapping inout UML::InstanceSpecification::ImplicitReadMe():UML::Usage@niemUml
{
	client+=self;
	var basePackage:UML::Package=self.getNearestPackage();
	basePackage.packagedElement+=result;
	var placeHolderPackage:UML::Package=basePackage.addPackage('readme.odt');
	supplier+=placeHolderPackage;
	result.ApplyStereotype(NIEMReadMe);
}
mapping UML::Usage::ReadMe(inout psmOwner:UML::InstanceSpecification,inout psmNiemNamespace:UML::Namespace):UML::Usage@niemUml
	inherits UML::Usage::ModelPackageDescriptionFile
	when{self.stereotypedBy('ReadMe')}
{
		self.ApplyFileTypeStereotype(NIEMReadMe,result);
}
mapping UML::Usage::Documentation(inout psmOwner:UML::InstanceSpecification,inout psmNiemNamespace:UML::Namespace):UML::Usage@niemUml
	inherits UML::Usage::ModelPackageDescriptionFile
	when{self.stereotypedBy('Documentation')}
{
		self.ApplyFileTypeStereotype(NIEMDocumentation,result);
}

mapping UML::Usage::File(inout psmOwner:UML::InstanceSpecification,inout psmNiemNamespace:UML::Namespace):UML::Usage@niemUml
	inherits UML::Usage::ModelPackageDescriptionFile
	when{self.stereotypedBy('File')}
{
		self.ApplyFileTypeStereotype(NIEMFile,result);
}
mapping UML::Usage::ConformanceAssertion(inout psmOwner:UML::InstanceSpecification,inout psmNiemNamespace:UML::Namespace):UML::Usage@niemUml
	inherits UML::Usage::ModelPackageDescriptionFile
	when{self.stereotypedBy('ConformanceAssertion')}
{
		self.ApplyFileTypeStereotype(NIEMConformanceAssertion,result);
}
mapping UML::Usage::BusinessRulesArtifact(inout psmOwner:UML::InstanceSpecification,inout psmNiemNamespace:UML::Namespace):UML::Usage@niemUml
	inherits UML::Usage::ModelPackageDescriptionFile
	when{self.stereotypedBy('BusinessRulesArtifact')}
{
		self.ApplyFileTypeStereotype(NIEMBusinessRulesArtifact,result);
}

mapping UML::Usage::IEPSampleXMLDocument(inout psmOwner:UML::InstanceSpecification,inout psmNiemNamespace:UML::Namespace):UML::Usage@niemUml
	inherits UML::Usage::ModelPackageDescriptionFile
	when{self.stereotypedBy('IEPSampleXMLDocument')}
{
		self.ApplyFileTypeStereotype(NIEMIEPSampleXMLDocument,result);
}

mapping UML::Usage::XMLSchemaDocument(inout psmOwner:UML::InstanceSpecification,inout psmNiemNamespace:UML::Namespace):UML::Usage@niemUml
	inherits UML::Usage::ModelPackageDescriptionFile
{
}

mapping UML::Usage::ExternalSchemaDocument(inout psmOwner:UML::InstanceSpecification,inout psmNiemNamespace:UML::Namespace):UML::Usage@niemUml
	inherits UML::Usage::XMLSchemaDocument
	when{self.stereotypedBy('ExternalSchemaDocument')}
{
		self.ApplyFileTypeStereotype(NIEMExternalSchemaDocument,result);
}
mapping UML::Usage::SubsetSchemaDocument(inout psmOwner:UML::InstanceSpecification,inout psmNiemNamespace:UML::Namespace):UML::Usage@niemUml
	inherits UML::Usage::XMLSchemaDocument
	when{self.stereotypedBy('SubsetSchemaDocument')}
{
		self.ApplyFileTypeStereotype(NIEMSubsetSchemaDocument,result);
}
mapping UML::Usage::ExtensionSchemaDocument(inout psmOwner:UML::InstanceSpecification,inout psmNiemNamespace:UML::Namespace):UML::Usage@niemUml
	inherits UML::Usage::XMLSchemaDocument
	when{self.stereotypedBy('ExtensionSchemaDocument')}
{
		self.ApplyFileTypeStereotype(NIEMExtensionSchemaDocument,result);
}
mapping UML::Usage::ReferenceSchemaDocument(inout psmOwner:UML::InstanceSpecification,inout psmNiemNamespace:UML::Namespace):UML::Usage@niemUml
	inherits UML::Usage::XMLSchemaDocument
	when{self.stereotypedBy('ReferenceSchemaDocument')}
{
		self.ApplyFileTypeStereotype(NIEMReferenceSchemaDocument,result);
}

mapping UML::Usage::RequiredFile(inout psmOwner:UML::PackageableElement,inout psmNiemNamespace:UML::Namespace):UML::Usage@niemUml
	inherits UML::Usage::ModelPackageDescriptionFile
	when{self.stereotypedBy('RequiredFile')}
{
		self.ApplyFileTypeStereotype(NIEMRequiredFile,result);
}
	
helper UML::Usage::ApplyFileTypeStereotype(fileTypeStereotype:UML::Stereotype,target:UML::Usage){
		var appliedSourceInstance:Stdlib::Element=self.GetStereotypeApplication(fileTypeStereotype);
		var appliedTargetInstance:Stdlib::Element=target.ApplyStereotype(fileTypeStereotype);
		appliedTargetInstance.setExternalURI(appliedSourceInstance.getExternalURI());
		appliedTargetInstance.setPathURI(appliedSourceInstance.getPathURI());
		appliedTargetInstance.setMimeMediaTypeText(appliedSourceInstance.getMimeMediaTypeText());
		appliedTargetInstance.setDescriptionText(appliedSourceInstance.getDescriptionText());
		// requiredFile set on the supplier side
		return;
}

mapping UML::Package::AttributeGroupDefinitions(inout psmOwner:UML::Package,domainContext:UML::Package):UML::Package@niemUml
	inherits UML::NamedElement::Package_init
	when{self.name=attributeGroupDefinitionPackageName}
{
	self.ownedType->select(t|t.oclIsKindOf(UML::Class)).oclAsType(UML::Class).map AttributeGroupDefinition(result,domainContext);
}
mapping UML::Class::AttributeGroupDefinition(inout psmOwner:UML::Element,domainContext:UML::Package):UML::Class@niemUml
	inherits UML::Classifier::NIEMComplexType
{
}

mapping UML::Usage::ModelPackageDescriptionFile(
	inout psmOwner:UML::PackageableElement,inout psmNiemNamespace:UML::Namespace
	)
	:UML::Usage@niemUml
{
	client+=psmOwner;
	psmOwner.getNearestPackage().packagedElement+=result;
	supplier+=psmNiemNamespace;
	
    self.getRequiredFileList()->forEach(requiredFile){
    	requiredFile.map RequiredFile(psmNiemNamespace.oclAsType(UML::PackageableElement),requiredFile.supplier->asSequence()->select(s|s.oclIsKindOf(UML::Namespace)).oclAsType(UML::Namespace)->first());
    };
}
mapping UML::InstanceSpecification::ModelPackageDescription(inout psmOwner:UML::Model,domainContext:UML::Package):UML::InstanceSpecification@niemUml
	inherits UML::NamedElement::Package_init
{
	mpdComponent:= result;
	if(isFirstComponent)	then{
		// to reduce chance of stack overflow, instantiate all schemas now, then instantiate all their owned types
		suppressPsmSchemaTypeMap:=true;
		gatherAllPimSchemas->forEach(pimPackage){
			var psmPackage:UML::Package=pimPackage.getPsmPackage(pimPackage);
		};
		suppressPsmSchemaTypeMap:=false;
		gatherAllPimSchemas->forEach(pimPackage){
			var psmPackage:UML::Package=pimPackage.getPsmPackage(pimPackage);
			pimPackage.ownedType.map AbstractXSDTypeDefinition(psmPackage,pimPackage);
		};
	// if any constraint schemas: duplicate the schemas in a constraint part of the psm (in constraint mode)
		if(gatherAllPimSchemas.getPimConstraintModels()->notEmpty() or gatherAllPimSchemas->select(s|s.hasPimConstraints())->notEmpty())then{
			var savePsmModel:Package=psmModel;
			psmModel:=savePsmModel.getConstraintPackage();
			constraintMode:=true;
			suppressPsmSchemaTypeMap:=true;
			gatherAllPimSchemas->forEach(pimPackage){
				var psmPackage:UML::Package=pimPackage.getPsmPackage(pimPackage);
			};
			suppressPsmSchemaTypeMap:=false;
			gatherAllPimSchemas->forEach(pimPackage){
				var psmPackage:UML::Package=pimPackage.getPsmPackage(pimPackage);
				pimPackage.ownedType.map AbstractXSDTypeDefinition(psmPackage,pimPackage);
			};
			constraintMode:=false;
			psmModel:=savePsmModel;
		}endif;
		isFirstComponent:=false;
	}endif;
	// map any explicit <<ModelPackageDefinitionFile>> Usages
	var hasReadMe:Boolean=false;
	var hasConformanceAssertion:Boolean=false;
	var hasConformanceReport:Boolean=false;
	var hasWantlist:Boolean=false;
	var hasOasisCatalog:Boolean=false;
	self.getMpdFileUsages()	
		->forEach(mpdFile){
			mpdFile.supplier->select(p|p.oclIsKindOf(UML::Package)).oclAsType(UML::Package)
			->forEach(pimPackage){
				var psmPackage:UML::Package=pimPackage.getPsmPackage(pimPackage);
		       mpdFile.source.map AbstractArtifactOrArtifactSet()->forEach(psmFileType){
					hasReadMe:=hasReadMe or mpdFile.stereotypedBy('ReadMe');
					hasConformanceAssertion:=hasConformanceAssertion or mpdFile.stereotypedBy('ConformanceAssertion');
					hasConformanceReport:=hasConformanceReport or mpdFile.stereotypedBy('ConformanceReport');
					hasWantlist:=hasWantlist or mpdFile.stereotypedBy('Wantlist');
					hasOasisCatalog:=hasOasisCatalog or mpdFile.stereotypedBy('XMLCatalog');
		       		mpdFile.map AbstractModelPackageDescriptionFile(result,psmPackage);
				};
				
			};
		};
	// process pim-specified <<InformationModel>>s and their types, (these should already have been done as part of first component above)
	var importedPackages:Set(UML::Package)=self.getPimInformationModels();
	// defer types
	importedPackages->forEach(pimPackage){
			var psmPackage:UML::Package=pimPackage.getPsmPackage(pimPackage);
			pimPackage.ownedType.map AbstractXSDTypeDefinition(psmPackage,pimPackage);
		};
	var pimmpdStereotypeInstance:UML::InstanceSpecification=self;
	pimmpdStereotypeInstance.deepcloneInstanceSpecification(prompdStereotype,result);
	
	// map any IEPConformanceTarget to psm
	result.getValueSpecification('IEPConformanceTarget')->select(v|v.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).mapAbstractIEPConformanceTarget();
	// known filesets
	self.mapModelPackageDescription(psmOwner,domainContext,result);
	// if no readme specified, add implicit
	// mpd relationships to either mpds or specifications;
	// should be sufficient to create the dependency with existing target
	var hasMPDRconformance:Boolean=false;
	var hasMPDRtargetAttributes:Boolean=false;
	var hasMPDRmpd:Boolean=false;
	var hasMPDRndr:Boolean=false;
	self.clientDependency->select(d|d.stereotypedBy('ModelPackageDescriptionRelationship'))->forEach(relationship){
		relationship.map ModelPackageDescriptionRelationship(result);
		var appliedSourceInstance:Stdlib::Element=relationship.GetStereotypeApplication(NIEMModelPackageDescriptionRelationshipStereotype);
		if(appliedSourceInstance.getRelationshipCode()='conforms_to')then{
			relationship.supplier->select(s|s.oclIsKindOf(UML::Package)).oclAsType(UML::Package)->forEach(p){
				if(not(p.URI.oclIsUndefined()) and (p.URI='http://reference.niem.gov/niem/specification/conformance/3.0/'))then{hasMPDRconformance:=true;}endif;
				if(not(p.URI.oclIsUndefined()) and (p.URI='http://reference.niem.gov/niem/specification/conformance-targets-attribute/3.0/'))then{hasMPDRtargetAttributes:=true;}endif;
				if(not(p.URI.oclIsUndefined()) and (p.URI='http://reference.niem.gov/niem/specification/model-package-description/3.0/'))then{hasMPDRmpd:=true;}endif;
				if(not(p.URI.oclIsUndefined()) and (p.URI='http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/'))then{hasMPDRndr:=true;}endif;
			};		
		}endif;
	};	
	if(not(hasMPDRconformance))then{
		result.map ImplicitMPDRconformance();
	}endif;
	if(not(hasMPDRtargetAttributes))then{
		result.map ImplicitMPDRtargetAttributes();
	}endif;
	if(not(hasMPDRmpd))then{
		result.map ImplicitMPDRmpd();
	}endif;
	if(not(hasMPDRndr))then{
		result.map ImplicitMPDRndr();
	}endif;
	
	if(not(hasOasisCatalog))then{
		result.map ImplicitOasisCatalog();
	}endif;
	if(not(hasWantlist))then{
		result.map ImplicitWantlist();
	}endif;
	if(not(hasConformanceReport))then{
		result.map ImplicitConformanceReport();
	}endif;
	if(not(hasReadMe))then{
		result.map ImplicitReadMe();
	}endif;
	if(not(hasConformanceAssertion))then{
		result.map ImplicitConformanceAssertion();
	}endif;
}
helper UML::InstanceValue::mapAbstractIEPConformanceTarget(){
	// map the instance specification to a psm
	var iv:UML::InstanceValue=self;
	var psmConformantTarget:UML::InstanceSpecification=iv.instance.map IEPConformanceTarget(iv);
	return;
}
mapping UML::InstanceSpecification::IEPConformanceTarget(inout psmInstanceValue:UML::InstanceValue):UML::InstanceSpecification
	{
		name:=self.name;
		result.setDescriptionText(self.getDescriptionText());
		
		psmInstanceValue.instance:=result;
		psmInstanceValue.getNearestPackage().packagedElement+=result;
	self.deepcloneInstanceSpecification(IEPConformanceTarget,result);
	result.getValueSpecification('ValidityConstraintWithContext')->select(v|v.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).mapAbstractValidityConstraintWithContext();
	
	self.getMpdFileUsages()	
		->forEach(mpdFile){
			mpdFile.supplier->select(p|p.oclIsKindOf(UML::Package)).oclAsType(UML::Package)
			->forEach(pimPackage){
				var psmPackage:UML::Package=pimPackage.getPsmPackage(pimPackage);
	       		mpdFile.map AbstractModelPackageDescriptionFile(result,psmPackage);
			};
		};
	}
helper UML::InstanceValue::mapAbstractValidityConstraintWithContext(){
	// map the instance specification to a psm
	var iv:UML::InstanceValue=self;
	var psmConformantTarget:UML::InstanceSpecification=iv.instance.map AbstractValidityConstraintWithContextType(iv);
	return;
}
mapping UML::InstanceSpecification::AbstractValidityConstraintWithContextType(inout psmInstanceValue:UML::InstanceValue):UML::InstanceSpecification
	disjuncts
		UML::InstanceSpecification::QualifiedNamesType,
		UML::InstanceSpecification::XPathType,
		UML::InstanceSpecification::XMLSchemaTypeX,// XMLSchemaValid
		UML::InstanceSpecification::SchematronValidationType,
		UML::InstanceSpecification::RelaxNGValidationType,
		UML::InstanceSpecification::ConformanceTargetType,
		UML::InstanceSpecification::TextRuleType,
		UML::InstanceSpecification::ValidityConstraintTypeX,
		UML::InstanceSpecification::ValidityContextType,
		UML::InstanceSpecification::ValidityConstraintWithContext
	{
	}
mapping UML::InstanceSpecification::XPathType(inout psmInstanceValue:UML::InstanceValue):UML::InstanceSpecification
	inherits UML::InstanceSpecification::ValidityConstraintTypeX
	when{self.classifier.name->includes('XPathType')}
	{
	self.deepcloneInstanceSpecification(XPathTypeArtifact,result);
	}
mapping UML::InstanceSpecification::XMLSchemaTypeX(inout psmInstanceValue:UML::InstanceValue):UML::InstanceSpecification
	inherits UML::InstanceSpecification::ValidityConstraintTypeX
	when{self.classifier.name->includes('XMLSchemaType')}
	{
	self.deepcloneInstanceSpecification(XMLSchemaTypeArtifact,result);
	self.getMpdFileUsages()	
		->forEach(mpdFile){
			mpdFile.supplier->select(p|p.oclIsKindOf(UML::Package)).oclAsType(UML::Package)
			->forEach(pimPackage){
				var psmPackage:UML::Package=pimPackage.getPsmPackage(pimPackage);
				log('map XMLSchemaTypeX to psmPackage '+psmPackage.qualifiedName);
	       		mpdFile.map AbstractModelPackageDescriptionFile(result,psmPackage);
			};
		};
	}
mapping UML::InstanceSpecification::SchematronValidationType(inout psmInstanceValue:UML::InstanceValue):UML::InstanceSpecification
	inherits UML::InstanceSpecification::ValidityConstraintTypeX
	when{self.classifier.name->includes('SchematronValidationType')}
	{
	self.deepcloneInstanceSpecification(SchematronValidationTypeArtifact,result);
	}
mapping UML::InstanceSpecification::RelaxNGValidationType(inout psmInstanceValue:UML::InstanceValue):UML::InstanceSpecification
	inherits UML::InstanceSpecification::ValidityConstraintTypeX
	when{self.classifier.name->includes('RelaxNGValidationType')}
	{
	self.deepcloneInstanceSpecification(RelaxNGValidationTypeArtifact,result);
	}
mapping UML::InstanceSpecification::ConformanceTargetType(inout psmInstanceValue:UML::InstanceValue):UML::InstanceSpecification
	inherits UML::InstanceSpecification::ValidityConstraintTypeX
	when{self.classifier.name->includes('ConformanceTargetType')}
	{
	self.deepcloneInstanceSpecification(ConformanceTargetTypeArtifact,result);
	}
mapping UML::InstanceSpecification::TextRuleType(inout psmInstanceValue:UML::InstanceValue):UML::InstanceSpecification
	inherits UML::InstanceSpecification::ValidityConstraintTypeX
	when{self.classifier.name->includes('TextRuleType')}
	{
	self.deepcloneInstanceSpecification(TextRuleTypeArtifact,result);
	}
mapping UML::InstanceSpecification::ValidityConstraintWithContext(inout psmInstanceValue:UML::InstanceValue):UML::InstanceSpecification
	{
		name:=self.name;
		result.setDescriptionText(self.getDescriptionText());
		psmInstanceValue.instance:=result;
		psmInstanceValue.getNearestPackage().packagedElement+=result;
	}
mapping UML::InstanceSpecification::QualifiedNamesType(inout psmInstanceValue:UML::InstanceValue):UML::InstanceSpecification
	inherits UML::InstanceSpecification::ValidityConstraintWithContext
	when{self.classifier.name->includes('QualifiedNamesType')}
	{
	self.deepcloneInstanceSpecification(QualifiedNamesTypeArtifact,result);
	}
mapping UML::InstanceSpecification::ValidityConstraintTypeX(inout psmInstanceValue:UML::InstanceValue):UML::InstanceSpecification
	inherits UML::InstanceSpecification::ValidityConstraintWithContext
	{
	}
mapping UML::InstanceSpecification::ValidityContextType(inout psmInstanceValue:UML::InstanceValue):UML::InstanceSpecification
	inherits UML::InstanceSpecification::ValidityConstraintWithContext
	when{self.classifier.name->includes('ValidityContextType')}
	{
	}
	
helper UML::InstanceSpecification::mapModelPackageDescription(inout psmOwner:UML::Model,domainContext:UML::Package,inout resultComponent:UML::InstanceSpecification){
	// for possible override
}
helper applyAdditionalProfiles(inout model:UML::Model){}// for possible override

mapping UML::InstanceSpecification::ModelPackageDescription_Model(inout psmOwner:UML::Model,domainContext:UML::Package):UML::Model@niemUml
	inherits UML::NamedElement::Package_init
{
	log('MPD defined by instance '+self.qualifiedName);
	psmModel:=result;
	result.applyProfile(provisioningProfile);
	result.applyProfile(structureProfile);
	result.applyProfile(niemXsdProfile);
	applyAdditionalProfiles(result);
	self.map ModelPackageDescription(result,domainContext);
}


mapping UML::Classifier::XSDTypeDefinition(inout psmOwner:UML::Element,domainContext:UML::Package):UML::Classifier@niemUml
	inherits UML::NamedElement::XSDNamedComponent
{
	init{
		if(psmOwner.oclIsKindOf(UML::Class))then{
			psmOwner.oclAsType(UML::Class).nestedClassifier+=result;
		}else{
			psmOwner.oclAsType(UML::Package).packagedElement+=result;
		}endif;
	}
        if(self.isNIEMConformant())then{
                name:=name.toTypeName();
        }endif;
	// propagate any References
	self.clientDependency.map AbstractReference(result,domainContext);
	self.generalization.map AbstractBaseTypeDefinition(result,domainContext);
	self.clientDependency
		->select(d|d.oclIsKindOf(UML::Realization))
		.oclAsType(UML::Realization).map NIEMRestriction(result,domainContext);
	isAbstract:=self.isAbstract;
	self.clientDependency.map XSDSimpleContent(result,domainContext); 
}

mapping UML::DataType::ObjectType_datatype(inout psmOwner:UML::Element,domainContext:UML::Package):UML::Class@niemUml
	inherits UML::Classifier::ObjectType
{
}
mapping UML::Class::ObjectType_class(inout psmOwner:UML::Element,domainContext:UML::Package):UML::Class@niemUml
	inherits UML::Classifier::ObjectType
{
}
mapping UML::Classifier::ObjectType(inout psmOwner:UML::Element,domainContext:UML::Package):UML::Classifier@niemUml
	inherits UML::Classifier::AugmentableType
{
	init{}
	result.ApplyStereotype(NIEMObjectTypeStereotype);
}
mapping UML::Classifier::AugmentableType(inout psmOwner:UML::Element,domainContext:UML::Package):UML::Classifier@niemUml
	inherits UML::Classifier::NIEMComplexType
{
	init{}
	// if complexContet
	var isComplexContent:Boolean=result.clientDependency
		->select(d|d.stereotypedBy('XSDSimpleContent'))->isEmpty();
		
	if(isComplexContent)then{
		// must have an AugmentationPoint; if not there then add it
		// if there are some form of augments, this must have an augmentationPoint
		//  note that subset of ref model may have intentionally removed autmentation point
		
		// pick up implicit augmentationPoint, if not already defined for an extension schema 
		//  and propagate any <<Augments>> as substitutionGroup to PropertyHolder
		var augmentationPoint:UML::Property=result.attribute->select(p|p.isAugmentationPoint())->asSequence()->first();
		if(augmentationPoint.oclIsUndefined())then{
			if(self.hasImplicitAugmentationPoint())then{
				// create an augmentation point and add to attribute
				augmentationPoint:=self.map ImplicitAugmentationPoint(result,domainContext);
			}endif;
		}endif;
		if(not(augmentationPoint.oclIsUndefined()))then{
			var topElementAugmentationPoint:UML::Property=self.resolveImplicitPropertyReference(augmentationPoint,domainContext);
			var topElementAugmentationPointPropertyHolder:UML::Class=topElementAugmentationPoint.namespace.oclAsType(UML::Class);
			self.getAugmentsRealizations()->forEach(augments){
				augments.client->select(c|c.oclIsKindOf(UML::Classifier)).oclAsType(UML::Classifier)->forEach(augmentation){
					var topElement:UML::Property=augmentation.makeTopLevelPSMAugmentationElement(augments,domainContext);
					// make Property in PropertyHolder in namespace of Realization; have it subset augmentationPoint
					// make sure topElementAugmentationPoint is same PropertyHolder or a super of topElement PropertyHolder
					var topElementPropertyHolder:UML::Class=topElement.namespace.oclAsType(UML::Class);
					if((topElementPropertyHolder<>topElementAugmentationPointPropertyHolder)
						and not(topElementPropertyHolder.general->includes(topElementAugmentationPointPropertyHolder)))then{
						var generalization:UML::Generalization=new UML::Generalization@niemUml();
						generalization.specific:=topElementPropertyHolder;
						generalization.general:=topElementAugmentationPointPropertyHolder;
					}endif;
					topElement.subsettedProperty+=topElementAugmentationPoint;
				};
			};
		}endif;
		
	}endif;
}
helper 	UML::Classifier::makeTopLevelPSMAugmentationElement(augments:UML::Realization,domainContext:UML::Package):UML::Property{
	var propertyName:String=augments.name;
	if(propertyName.oclIsUndefined() or (propertyName=''))then{
		propertyName:=self.name.replace('AugmentationType','Augmentation');
	}endif;
	var pimAugmentsPackage:UML::Package=augments.getNearestNIEMSchemaPackage();
	var psmAugmentsPackage:UML::Package=pimAugmentsPackage.getPsmPackage(domainContext);
	// check if property already defined
    psmAugmentsPackage.getPropertyHolders().attribute->select(p|p.name=propertyName)
	->forEach(existingProperty){
		return existingProperty;
	};
	// the property may already exist (to support instance document validation)
	// we need to check PIM <<PropertyHolder>>s for the property
	var existingPimImplicitProperty:Property=pimAugmentsPackage.getPropertyHolders().ownedAttribute
        ->select(p|p.name=propertyName)->asSequence()->first();
	
	if(not(existingPimImplicitProperty.oclIsUndefined()))then{
		return existingPimImplicitProperty.getPsmProperty(domainContext);
	}endif;

    var psmHolder:UML::Class=psmAugmentsPackage.getTopLevelPsmPropertyHolder();
	var psmProperty:UML::Property=new UML::Property@niemUml();
	psmHolder.ownedAttribute+=psmProperty;

	var stereotypeInstance:Stdlib::Element=psmProperty.ApplyStereotype(NIEMPropertyStereotype);
	stereotypeInstance.setNIEMPropertyKind('element');
	stereotypeInstance.setNIEMPropertyNillable(false);

	psmProperty.name:=propertyName;
	psmProperty.isDerived:=false;
	psmProperty.isReadOnly:=false;
	psmProperty.setLower(0);
	psmProperty.setUpper(-1);

	psmProperty.isOrdered:=false;
	psmProperty.isUnique:=false;
	psmProperty.aggregation:=UML::AggregationKind::shared;
	psmProperty.type:=self.oclAsType(UML::Classifier).getPsmClassifier(domainContext);
	
	var comment:UML::Comment=new UML::Comment@niemUml();
	psmProperty.ownedComment+=comment;
	comment.annotatedElement+=psmProperty;
	augments.ownedComment.body->forEach(b){comment.body:=b;};
	if(comment.body.oclIsUndefined())then{
		comment.body:='Additional information about the '+propertyName.replace('Augmentation','')+'.';
	}endif;	
	comment.ApplyStereotype(NIEMDescriptionStereotype);
	
	return psmProperty;
}

mapping UML::Class::AssociationType_class(inout psmOwner:UML::Element,domainContext:UML::Package):UML::Class@niemUml
	inherits UML::Classifier::AssociationType
	when{self.IsStereotypeApplied(NIEMAssociationStereotype)}
{
}
mapping UML::Classifier::AssociationType(inout psmOwner:UML::Element,domainContext:UML::Package):UML::Classifier@niemUml
	inherits UML::Classifier::AugmentableType
	
{
	init{}
	result.ApplyStereotype(NIEMAssociationStereotype);
	name:=result.name.toNIEMAssociationName();
}
mapping UML::Class::MetadataType_class(inout psmOwner:UML::Element,domainContext:UML::Package):UML::Class@niemUml
	inherits UML::Classifier::MetadataType
	when{self.IsStereotypeApplied(NIEMMetadataStereotype)}
{
}
mapping UML::Classifier::MetadataType(inout psmOwner:UML::Element,domainContext:UML::Package):UML::Classifier@niemUml
	inherits UML::Classifier::NIEMComplexType
{
	init{}
	result.ApplyStereotype(NIEMMetadataStereotype);
	name:=result.name.toNIEMMetadataName();
}
mapping UML::Class::AdapterType_class(inout psmOwner:UML::Element,domainContext:UML::Package):UML::Class@niemUml
	inherits UML::Classifier::AdapterType
	when{self.IsStereotypeApplied(NIEMAdapterStereotype)}
{
}
mapping UML::Classifier::AdapterType(inout psmOwner:UML::Element,domainContext:UML::Package):UML::Classifier@niemUml
	inherits UML::Classifier::NIEMComplexType
{
	init{}
	result.ApplyStereotype(NIEMAdapterStereotype);
	name:=result.name.toNIEMAdapterName();
}
mapping UML::Class::TopLevel(inout psmOwner:UML::Element,domainContext:UML::Package):UML::Class@niemUml
	inherits UML::Classifier::NIEMComplexType
	when{self.IsStereotypeApplied(NIEMPropertyHolderStereotype)}
{
	result.ApplyStereotype(NIEMPropertyHolderStereotype);
}
mapping UML::Class::AugmentationType_class(inout psmOwner:UML::Element,domainContext:UML::Package):UML::Class@niemUml
	inherits UML::Classifier::AugmentationType
	when{self.IsStereotypeApplied(NIEMAugmentationStereotype)}
{
}
mapping UML::Classifier::AugmentationType(inout psmOwner:UML::Element,domainContext:UML::Package):UML::Classifier@niemUml
	inherits UML::Classifier::NIEMComplexType
{
	init{}
	result.ApplyStereotype(NIEMAugmentationStereotype);
	name:=result.name.toNIEMAugmentationName();
}
mapping UML::Classifier::NIEMComplexType(inout psmOwner:UML::Element,domainContext:UML::Package):UML::Classifier@niemUml
	inherits UML::Classifier::XSDTypeDefinition,
	UML::Classifier::Choice
	{
		init{}
	self.getOrderedProperties().map AbstractXSDFeature(result,domainContext);
}
query UML::Classifier::hasImplicitAugmentationPoint():Boolean{
	// some form of <<Augments>> and does not already have an AugmentationPoint
	self.attribute->select(a|a.isAugmentationPoint())->forEach(augmentationPoint){return false;};
	return self.getAugmentsRealizations()->notEmpty() or 
		self.generalization->exists(g|g.general.isNiemAugmentationType()  and not(g.specific.isNiemAugmentationType()));
}
query UML::Classifier::getAugmentsRealizations():Set(UML::Realization)
	=self.supplierDependency->select(d|d.stereotypedBy('Augments')).oclAsType(UML::Realization)->asSet();


mapping UML::AssociationClass::AssociationType_associationClass(
	inout psmOwner:UML::Element,domainContext:UML::Package):UML::Class@niemUml
	inherits
		UML::Classifier::AssociationType{
}
mapping UML::Property::NIEMProperty_associationClassEnd(
	inout classifier:UML::Classifier,domainContext:UML::Package):UML::Property@niemUml
	inherits UML::Property::NIEMProperty
	when{not(self.association.oclIsUndefined()) and self.association.oclIsKindOf(UML::AssociationClass)}
	{
			// adjust property multiplicities
			result.setLower(1);
			result.setUpper(1);
	}




mapping UML::DataType::NIEMComplexType_simpleContent(inout psmOwner:UML::Element,domainContext:UML::Package):UML::Class@niemUml
	inherits UML::Classifier::NIEMComplexType{
	result.ApplyStereotype(NIEMObjectTypeStereotype);
}

mapping UML::Classifier::Choice(
	inout psmOwner:UML::Element,domainContext:UML::Package)
	:UML::Classifier@niemUml
	when{self.IsStereotypeApplied(NIEMChoiceStereotype)}
	{
		init{}
	result.ApplyStereotype(NIEMChoiceStereotype);
}

mapping UML::PrimitiveType::NIEMSimpleType_primitive(
	inout psmOwner:UML::Element,domainContext:UML::Package):UML::PrimitiveType@niemUml
	inherits UML::DataType::NIEMSimpleType
	when{self.isPimSimpleTypeDefinition()
		or self.isRestricted()
	}
	{
}
mapping UML::Usage::UnionOf(
	inout psmOwner:UML::DataType,domainContext:UML::Package):UML::Usage@niemUml
	{
		psmOwner.getNearestPackage().packagedElement+=result;
		client+=psmOwner;
		supplier+=self.supplier.oclAsType(UML::DataType).getPsmClassifier(domainContext);
		result.applyStereotype(NIEMUnionOfStereotype);
	}
mapping UML::Realization::TypeDefinition(
	inout psmOwner:UML::DataType,domainContext:UML::Package):UML::Realization@niemUml
	{
		psmOwner.getNearestPackage().packagedElement+=result;
		client+=psmOwner;
		supplier+=self.supplier.oclAsType(UML::DataType).getPsmClassifier(domainContext);
	}
mapping UML::DataType::NIEMSimpleType_typedefinition(
	inout psmOwner:UML::Element,domainContext:UML::Package):UML::DataType@niemUml
	inherits UML::Classifier::XSDTypeDefinition
	{
	// coerce name to NIEM compliant only if schema is niem-conformant, part of Issue 18251: NIEM-UML Issue: Constraint schema 
     if(self.isNIEMConformant())then{
            name:=result.name.toNIEMSimpleTypeName();
    }endif;
	self.clientDependency.map AbstractTypeDefinition(result,domainContext);
}
mapping UML::DataType::NIEMSimpleType_list(
	inout psmOwner:UML::Element,domainContext:UML::Package):UML::DataType@niemUml
	inherits UML::DataType::NIEMSimpleType_typedefinition
	when{self.IsStereotypeApplied(NIEMListTypeStereotype)}
	{
	result.ApplyStereotype(NIEMListTypeStereotype);
	self.getOrderedProperties().map AbstractXSDFeature(result,domainContext);// the item property

}
mapping UML::DataType::NIEMSimpleType_union(
	inout psmOwner:UML::Element,domainContext:UML::Package):UML::DataType@niemUml
	inherits UML::DataType::NIEMSimpleType_typedefinition
	when{self.IsStereotypeApplied(NIEMUnionTypeStereotype)}
	{
	result.ApplyStereotype(NIEMUnionTypeStereotype);
}
helper UML::DataType::NIEMSimpleTypePSM(inout psmOwner:UML::Element,domainContext:UML::Package,inout psmResult:UML::DataType){
	var psmSimpleTypeDefinitionInstance:Stdlib::Element=psmResult.ApplyStereotype(NIEMSimpleTypeStereotype);
	var pimSimpleTypeDefinitionInstance:Stdlib::Element=self.GetStereotypeApplication(NIEMSimpleTypeStereotype).oclAsType(Stdlib::Element);
	var fractionDigits:Integer=pimSimpleTypeDefinitionInstance.getNIEMSimpleTypeFractionDigits();
	var maxExclusive:String=pimSimpleTypeDefinitionInstance.getNIEMSimpleTypeMaxExclusive();
	var maxInclusive:String=pimSimpleTypeDefinitionInstance.getNIEMSimpleTypeMaxInclusive();
	var patterns:Sequence(String)=pimSimpleTypeDefinitionInstance.getNIEMSimpleTypePattern();
	var totalDigits:Integer=pimSimpleTypeDefinitionInstance.getNIEMSimpleTypeTotalDigits();
	var length:Integer=pimSimpleTypeDefinitionInstance.getNIEMSimpleTypeLength();
	var minExclusive:String=pimSimpleTypeDefinitionInstance.getNIEMSimpleTypeMinExclusive();
	var minInclusive:String=pimSimpleTypeDefinitionInstance.getNIEMSimpleTypeMinInclusive();
	var maxLength:Integer=pimSimpleTypeDefinitionInstance.getNIEMSimpleTypeMaxLength();
	var minLength:Integer=pimSimpleTypeDefinitionInstance.getNIEMSimpleTypeMinLength();
	if(not(fractionDigits.oclIsUndefined()))then {
		psmSimpleTypeDefinitionInstance.setNIEMSimpleTypeFractionDigits(fractionDigits);
		}endif;
	if(not(maxExclusive.oclIsUndefined()))then {
	psmSimpleTypeDefinitionInstance.setNIEMSimpleTypeMaxExclusive(maxExclusive);
		}endif;
	if(not(maxInclusive.oclIsUndefined()))then {
	psmSimpleTypeDefinitionInstance.setNIEMSimpleTypeMaxInclusive(maxInclusive);
		}endif;
	psmSimpleTypeDefinitionInstance.setNIEMSimpleTypePattern(patterns);
	if(not(totalDigits.oclIsUndefined()))then {
	psmSimpleTypeDefinitionInstance.setNIEMSimpleTypeTotalDigits(totalDigits);
		}endif;
	if(not(length.oclIsUndefined()))then {
	psmSimpleTypeDefinitionInstance.setNIEMSimpleTypeLength(length);
		}endif;

	if(not(minExclusive.oclIsUndefined()))then {
	psmSimpleTypeDefinitionInstance.setNIEMSimpleTypeMinExclusive(minExclusive);
		}endif;

	if(not(minInclusive.oclIsUndefined()))then {
	psmSimpleTypeDefinitionInstance.setNIEMSimpleTypeMinInclusive(minInclusive);
		}endif;

	if(not(maxLength.oclIsUndefined()))then {
	psmSimpleTypeDefinitionInstance.setNIEMSimpleTypeMaxLength(maxLength);
		}endif;

	if(not(minLength.oclIsUndefined()))then {
	psmSimpleTypeDefinitionInstance.setNIEMSimpleTypeMinLength(minLength);
		}endif;

	var representationStereotypeInstance:Stdlib::Element=self.GetStereotypeApplication(NIEMRepresentationRestrictionStereotype).oclAsType(Stdlib::Element);
	if(not(representationStereotypeInstance.oclIsUndefined()))then{
		representationStereotypeInstance.deepcloneStereotypeApplication(NIEMRepresentationRestrictionStereotype,psmResult);
	}endif;
	// name coercion for niem-conformant schemas, including test if target is complex or simple type, per Issue 18361: PSM Representation for XSD Complex Type with Simple Content 
     if(self.isNIEMConformant())then{
    	var isSimple:Boolean=self.isPimSimpleTypeDefinition()
    		and not(self.isProxyRestriction());
    	if(isSimple)then{
	            psmResult.name:=psmResult.name.toNIEMSimpleTypeName();
            }else{
                psmResult.name:=psmResult.name.toTypeName();
            }endif;
    }endif;
	
}

mapping UML::DataType::NIEMSimpleType(inout psmOwner:UML::Element,domainContext:UML::Package):UML::DataType@niemUml
	inherits UML::Classifier::XSDTypeDefinition
	// extended conditions for transforming to DataType per Issue 18361: PSM Representation for XSD Complex Type with Simple Content 
	when{self.isPimSimpleTypeDefinition() 
		or self.isRestricted()
		}
	{
		self.NIEMSimpleTypePSM(psmOwner,domainContext,result);
}
mapping UML::Enumeration::NIEMLocalVocabulary(
	inout psmOwner:UML::Element,domainContext:UML::Package):UML::Enumeration@niemUml
	inherits UML::Classifier::XSDTypeDefinition
	when{self.IsStereotypeApplied(NIEMLocalVocabularyStereotype) 
	}
	{
	var psmSimpleTypeDefinitionInstance:Stdlib::Element=result.ApplyStereotype(NIEMLocalVocabularyStereotype);
	name:=self.name;
	// process content
	var codeValues:OrderedSet(UML::EnumerationLiteral)=self.ownedLiteral;
	codeValues->forEach(codeValue){
		var psmCodeValue:UML::EnumerationLiteral=new UML::EnumerationLiteral@niemUml();
		result.ownedLiteral+=psmCodeValue;
		psmCodeValue.name:=codeValue.name;
		codeValue.getPimComment()
		->forEach(comment){
			var psmComment:UML::Comment=new UML::Comment@niemUml();
			psmCodeValue.ownedComment+=psmComment;
			psmComment.annotatedElement:=psmCodeValue;
			psmComment.body:=comment.body;
			psmComment.ApplyStereotype(NIEMDescriptionStereotype);
			};
		if(codeValue.IsStereotypeApplied(NIEMLocalTermStereotype))then{
			var pimStereotypeInstance:Stdlib::Element=codeValue.GetStereotypeApplication(NIEMLocalTermStereotype).oclAsType(Stdlib::Element);
			pimStereotypeInstance.deepcloneStereotypeApplication(NIEMLocalTermStereotype,psmCodeValue);
			}endif;
	};		
}

helper UML::Enumeration::NIEMSimpleType_enumerationPopulate(inout psmOwner:UML::Element,domainContext:UML::Package,inout psmEnumeration:UML::Enumeration){
		
	// process content
	var codeValues:OrderedSet(UML::EnumerationLiteral)=self.ownedLiteral;
	var simpleTypePSM:UML::Enumeration=psmEnumeration;
	// refined name coercion as part of Issue 18361: PSM Representation for XSD Complex Type with Simple Content 
	// name coercion applies only if schema is niem-conformant,
	// check if this corresponds to a complex or simple type
	 if(self.isNIEMConformant())then{
    	// this is complex if its base is complex
    	var isComplex:Boolean=(self.getGeneralRestrictions()->select(r|not(r.isPimSimpleTypeDefinition()))->size()=1)
    		or self.isLeaf
    		or self.isProxyRestriction()
    		or self.isPimComplexTypeSimpleContent();
	 	if(isComplex)then{
            psmEnumeration.name:=psmEnumeration.name.toNIEMCodeName();
    	}else{
            psmEnumeration.name:=psmEnumeration.name.toNIEMCodeSimpleName();
        }endif;
    }endif;
	self.NIEMSimpleTypePSM(psmOwner,domainContext,simpleTypePSM);
	codeValues->forEach(codeValue){
		var psmCodeValue:UML::EnumerationLiteral=new UML::EnumerationLiteral@niemUml();
		simpleTypePSM.ownedLiteral+=psmCodeValue;
		// refined name to include <<NIEMName>>, part of Issue 18361: PSM Representation for XSD Complex Type with Simple Content 
		psmCodeValue.name:=codeValue.getBaseNiemName();
		codeValue.ownedComment->forEach(comment){
			var psmComment:UML::Comment=new UML::Comment@niemUml();
			psmCodeValue.ownedComment+=psmComment;
			psmComment.annotatedElement:=psmCodeValue;
			psmComment.body:=comment.body;
			psmComment.ApplyStereotype(NIEMDescriptionStereotype);
			};

	};
	if(self.IsStereotypeApplied(NIEMUnionTypeStereotype))then
	{
		simpleTypePSM.ApplyStereotype(NIEMUnionTypeStereotype);
		// union of
		self.clientDependency.map AbstractTypeDefinition(simpleTypePSM,domainContext);
	}else{
		if(self.getGeneralRestrictions()->isEmpty())then{
		// must lead to xsd token base
			var restriction:UML::Realization=new UML::Realization@niemUml();
			psmEnumeration.getNearestPackage().packagedElement+=restriction;
			restriction.client+=simpleTypePSM;
			// token from xmlLibrary
			var type:UML::Type=umlXmlLibrary.ownedType->select(t|t.name='token')->asSequence()->first();
	
			restriction.supplier+=type.oclAsType(UML::Classifier).getPsmClassifier(domainContext);
			// correction to applying <<Restriction>> as part of Issue 18361: PSM Representation for XSD Complex Type with Simple Content 
			restriction.ApplyStereotype(NIEMRestrictionStereotype);
			// added markings for restriction from proxy, if necessary, as part of Issue 18361: PSM Representation for XSD Complex Type with Simple Content 
			if(self.isLeaf)then{
				var opaqueExpression:UML::OpaqueExpression=new UML::OpaqueExpression@niemUml();
				opaqueExpression.language+='English';
				opaqueExpression.body+='via Proxy';
				restriction._mapping:=opaqueExpression;
			}endif;
		}endif;
	}endif;
	return;
}


mapping UML::Enumeration::NIEMSimpleType_enumeration(
	inout psmOwner:UML::Element,domainContext:UML::Package):UML::Enumeration@niemUml
	inherits UML::Classifier::XSDTypeDefinition
	when{self.isPimSimpleTypeDefinition()
		or self.ownedLiteral->notEmpty()
		or self.IsStereotypeApplied(NIEMSimpleTypeStereotype) 
		or self.IsStereotypeApplied(NIEMRepresentationRestrictionStereotype)
	}
	{
	self.NIEMSimpleType_enumerationPopulate(psmOwner,domainContext,result);
}
query UML::Enumeration::isCompactEnumeration():Boolean=
	self.ownedLiteral->notEmpty()
	and self.isNIEMConformant()
	and not(self.IsStereotypeApplied(NIEMUnionTypeStereotype))
	and self._classifierOfGeneral->isEmpty()
	and self.supplierDependency->select(d|d.isStereotypeApplied(NIEMRestrictionStereotype))->isEmpty()
	and self.supplierDependency->select(d|d.isStereotypeApplied(NIEMUnionOfStereotype))->isEmpty()
	and self._typedElementOfType->select(p|p.oclIsKindOf(UML::Property)).oclAsType(UML::Property)
		->select(d|d.namespace.isStereotypeApplied(NIEMListTypeStereotype) or not(d.isPsmXsdElement()))
		->isEmpty()
	;
	
mapping UML::Enumeration::NIEMMergedType_enumeration(
	inout psmOwner:UML::Element,domainContext:UML::Package):UML::Class@niemUml
	inherits UML::DataType::NIEMComplexType_simpleContent
	when{self.isCompactEnumeration()}	
	{
	// refined name coercion as part of Issue 18361: PSM Representation for XSD Complex Type with Simple Content 
	// name coercion applies only if schema is niem-conformant,
	// check if this corresponds to a complex or simple type
        	// create another Enumeration to represent the SimpleType; 
        	var simpleTypePSM:UML::Enumeration=new UML::Enumeration@niemUml();
            name:=result.name.toNIEMCodeName();
            simpleTypePSM.name:=result.name.toNIEMCodeSimpleName();
            psmOwner.getNearestPackage().packagedElement+=simpleTypePSM;
			self.getPimComment()
				->forEach(comment){simpleTypePSM.map Description(comment.body,simpleTypePSM);};
			if(self.stereotypedBy('Deprecated'))then{
				simpleTypePSM.ApplyStereotype(NIEMDeprecatedStereotype);
			}endif;	
        	// hook up the complex with the simple
        	var simpleContent:UML::Realization=new UML::Realization@niemUml();
			psmOwner.getNearestPackage().packagedElement+=simpleContent;
			simpleContent.client+=result;
			simpleContent.supplier+=simpleTypePSM;
			simpleContent.ApplyStereotype(NIEMSimpleContentStereotype);
			result.ApplyStereotype(NIEMObjectTypeStereotype);
			
	self.NIEMSimpleType_enumerationPopulate(psmOwner,domainContext,simpleTypePSM);
}
mapping UML::Enumeration::NIEMComplexType_enumeration(
	inout psmOwner:UML::Element,domainContext:UML::Package):UML::Class@niemUml
	inherits UML::DataType::NIEMComplexType_simpleContent{
	// name coercion only if in niem-conformant schema, part of Issue 18361: PSM Representation for XSD Complex Type with Simple Content 
     if(self.isNIEMConformant())then{
            name:=result.name.toNIEMCodeName();
    }endif;
}
mapping UML::DataType::NIEMComplexType_datatype(
	inout psmOwner:UML::Element,domainContext:UML::Package):UML::Class@niemUml
	inherits UML::DataType::NIEMComplexType_simpleContent
	when{self.inheritsXmlPrimitive()}
	{
}
mapping UML::Property::XSDFeature_init(inout classifier:UML::Classifier,domainContext:UML::Package):UML::Property@niemUml
	inherits UML::NamedElement::XSDNamedComponent
{
	init{
		switch{
			case(classifier.oclIsKindOf(UML::Class))
				classifier.oclAsType(UML::Class).ownedAttribute+=result;
			else classifier.oclAsType(UML::DataType).ownedAttribute+=result;
		};

	}
	// propagate any References
	self.clientDependency.map AbstractReference(result,domainContext);
    var attr:UML::Property=self;
	// name coercion includes <<NIEMName>> name if required, part of Issue 18361: PSM Representation for XSD Complex Type with Simple Content 
   var propertyName:String=attr.getBaseNiemName().toNCName();
	name:=propertyName;
	// when in constraint mode, use property override from a constraint model as basis for PSM property, part of Issue 18251: NIEM-UML Issue: Constraint schema 
    var useSelf:UML::Property=self.toMappingConstraintProperty();
	isDerived:=useSelf.isDerived;
	isReadOnly:=useSelf.isReadOnly;
	result.setLower(useSelf.lower);
	result.setUpper(useSelf.upper);

	isOrdered:=useSelf.isOrdered;
	isUnique:=useSelf.isUnique;
	aggregation:=useSelf.aggregation;

	var sourceType:UML::Type=useSelf.getConstraintPropertyType();
	if(not(sourceType.oclIsUndefined()))then{
		result.type:=sourceType.oclAsType(UML::Classifier).getPsmClassifier(domainContext);
	}endif;
}
mapping UML::Property::NIEMAnyProperty(inout classifier:UML::Classifier,domainContext:UML::Package):UML::Property@niemUml
	inherits UML::Property::XSDFeature_init
	when{self.isXsdWildcard()}
	{
	switch{
		case(self.IsStereotypeApplied(NIEMAnyPropertyStereotype))
			self.GetStereotypeApplication(NIEMAnyPropertyStereotype).oclAsType(Stdlib::Element).deepcloneStereotypeApplication(NIEMAnyPropertyStereotype,result);
		else{
			var stereotypeInstance:Stdlib::Element=result.ApplyStereotype(NIEMAnyPropertyStereotype);
			stereotypeInstance.setNIEMAnyPropertyProcessContents(self.name);
		};
	};
	}

mapping UML::Generalization::NIEMProperty_implicit(
	inout psmOwner:UML::Classifier,domainContext:UML::Package)
		:UML::Property@niemUml
		inherits UML::Element::XSDComponent{
		switch{
			case(psmOwner.oclIsKindOf(UML::Class))
				psmOwner.oclAsType(UML::Class).ownedAttribute+=result;
			else psmOwner.oclAsType(UML::DataType).ownedAttribute+=result;
		};

		var stereotypeInstance:Stdlib::Element=result.ApplyStereotype(NIEMPropertyStereotype);
		stereotypeInstance.setNIEMPropertyKind('element');
		name:=self.getBaseNiemName(self.general.name).firstToUpper().toNCName();
		
		result.setLower(1);
		result.setUpper(1);


	isDerived:=false;
	isReadOnly:=false;
	isOrdered:=true;
	isUnique:=true;
		aggregation:=UML::AggregationKind::none;

	result.type:=self.general.getPsmClassifier(domainContext);
}

mapping UML::Generalization::NIEMProperty_augmentation(inout classifier:UML::Classifier,domainContext:UML::Package):UML::Property@niemUml
	inherits UML::Generalization::NIEMProperty_implicit
	when{self.general.isNiemAugmentationType()  and not(self.specific.isNiemAugmentationType())}
	{
	// added all following as part of Issue 18361: PSM Representation for XSD Complex Type 
	// name coercian of target Property based on <<NIEMName>> applied to Generalization
	name:=self.getBaseNiemName(self.general.name).firstToUpper().toNCName();
	// aggregation forced to be shared
	aggregation:=UML::AggregationKind::shared;
	// resolve or create top level element corresponding to augmentation element
	//  for niem3, the augmentation element can not be owned by classifier, so make this top-level and hook into augmentationPoint
	var topElement:UML::Property=result;
	var psmHolder:UML::Class=classifier.getNearestNIEMSchemaPackage().getTopLevelPsmPropertyHolder();
	psmHolder.ownedAttribute+=topElement;
	
	
	//  find or create AugmentationPoint 
	var augmentableType:UML::Classifier=self.specific.getPsmClassifier(domainContext);
	var augmentationPoint:UML::Property=augmentableType.attribute->select(p|p.isAugmentationPoint())->asSequence()->first();
	if(augmentationPoint.oclIsUndefined())then{
		augmentationPoint:=self.specific.map ImplicitAugmentationPoint(augmentableType,domainContext);
	}endif;
	var topElementAugmentationPoint:UML::Property=self.specific.resolveImplicitPropertyReference(augmentationPoint,domainContext);
	// make sure topElementAugmentationPoint is same PropertyHolder or a super of topElement PropertyHolder
	var topElementAugmentationPointPropertyHolder:UML::Class=topElementAugmentationPoint.namespace.oclAsType(UML::Class);
	var topElementPropertyHolder:UML::Class=topElement.namespace.oclAsType(UML::Class);
	if(topElementPropertyHolder<>topElementAugmentationPointPropertyHolder)then{
		var generalization:UML::Generalization=new UML::Generalization@niemUml();
		generalization.specific:=topElementPropertyHolder;
		generalization.general:=topElementAugmentationPointPropertyHolder;
	}endif;
	
	topElement.subsettedProperty+=topElementAugmentationPoint;
	}

mapping UML::Generalization::NIEMRoleOf_generalization(
	inout classifier:UML::Classifier,domainContext:UML::Package):UML::Property@niemUml
	inherits UML::Generalization::NIEMProperty_implicit
	when{self.IsStereotypeApplied(NIEMRoleStereotype)}
	{
		// name coercion optionally based on <<NIEMName>> name, as part of Issue 18361: PSM Representation for XSD Complex Type 
		name:=self.getBaseNiemName(self.general.name).firstToUpper().toNCName().toRoleOfName();

	// this property owned by a non-PropertyHolder, make sure there is a resolved reference
	self.resolveImplicitPropertyReference(result,domainContext);

	}
mapping UML::Classifier::ImplicitAugmentationPoint(inout classifier:UML::Classifier,domainContext:UML::Package):UML::Property@niemUml
		inherits UML::Element::XSDComponent{
		switch{
			case(classifier.oclIsKindOf(UML::Class))
				classifier.oclAsType(UML::Class).ownedAttribute+=result;
			else classifier.oclAsType(UML::DataType).ownedAttribute+=result;
		};

		var stereotypeInstance:Stdlib::Element=result.ApplyStereotype(NIEMPropertyStereotype);
		stereotypeInstance.setNIEMPropertyKind('element');
		result.setLower(0);
		result.setUpper(-1);
	isDerived:=true;
	isReadOnly:=false;
	isOrdered:=true;
	isUnique:=true;
	isDerivedUnion:=true;

	result.type:=null;
	name:=self.getBaseNiemName(self.name).firstToUpper().toNCName()+'AugmentationPoint';
	// aggregation forced to be shared
	aggregation:=UML::AggregationKind::shared;
	// resolve or create top level element corresponding to augmentation point
	var topElement:UML::Property=self.resolveImplicitPropertyReference(result,domainContext);
	
	var comment:UML::Comment=new UML::Comment@niemUml();
	ownedComment+=comment;
	comment.annotatedElement+=result;
	comment.body:='An augmentation point for '+self.name+'.';
	comment.ApplyStereotype(NIEMDescriptionStereotype);
	
	}
	
helper 	UML::Element::resolveImplicitPropertyReference(psmContext:UML::Property,domainContext:UML::Package):UML::Property{
	var referencedPSMTopLevelProperty:UML::Property=self.makeTopLevelPSMImplicitProperty(psmContext,domainContext);
	// add a reference to the top level property
	var reference:UML::Realization=new UML::Realization@niemUml();
	psmContext.getNearestPackage().packagedElement+=reference;
	reference.client+=psmContext;
	reference.supplier+=referencedPSMTopLevelProperty;
	reference.ApplyStereotype(NIEMReferencesStereotype);
	return referencedPSMTopLevelProperty;
}
helper 	UML::Element::makeTopLevelPSMImplicitProperty(psmContext:UML::Property,domainContext:UML::Package):UML::Property{
	var propertyName:String=psmContext.name;

	// check if property already defined
        psmContext.getNearestNIEMSchemaPackage().getPropertyHolders().attribute->select(p|p.name=propertyName)
	->forEach(existingProperty){
		return existingProperty;
	};
	// the property may already exist (to support instance document validation)
	// we need to check PIM <<PropertyHolder>>s for the property
	var existingPimImplicitProperty:Property=		self.resolvePIMImplicitPropertyReference(psmContext);
	if(not(existingPimImplicitProperty.oclIsUndefined()))then{
		return existingPimImplicitProperty.getPsmProperty(domainContext);
	}endif;

        var psmHolder:UML::Class=psmContext.getNearestNIEMSchemaPackage().getTopLevelPsmPropertyHolder();
	var psmProperty:UML::Property=new UML::Property@niemUml();
	psmHolder.ownedAttribute+=psmProperty;
		var isElement:Boolean=psmContext.isPsmXsdElement();

	switch{
		case(psmContext.IsStereotypeApplied(NIEMPropertyStereotype))
			psmContext.GetStereotypeApplication(NIEMPropertyStereotype).oclAsType(Stdlib::Element).deepcloneStereotypeApplication(NIEMPropertyStereotype,psmProperty);
		else{
			var stereotypeInstance:Stdlib::Element=psmProperty.ApplyStereotype(NIEMPropertyStereotype);
			stereotypeInstance.setNIEMPropertyKind(if(isElement)then 'element' else 'attribute' endif);
			stereotypeInstance.setNIEMPropertyNillable(false);
		};
	};
	var attr:UML::Property=psmContext;
	psmProperty.name:=propertyName;
	psmProperty.isDerived:=attr.isDerived;
	psmProperty.isReadOnly:=attr.isReadOnly;
	psmProperty.setLower(attr.lower);
	psmProperty.setUpper(attr.upper);

	psmProperty.isOrdered:=attr.isOrdered;
	psmProperty.isUnique:=attr.isUnique;
	psmProperty.aggregation:=attr.aggregation;
	psmProperty.type:=attr.getConstraintPropertyType();
	psmContext.getPimComment()
	.body->forEach(body){
		var comment:UML::Comment=new UML::Comment@niemUml();
		psmProperty.ownedComment+=comment;
		comment.annotatedElement+=psmProperty;
		comment.body:=body;
		comment.ApplyStereotype(NIEMDescriptionStereotype);
	};
	return psmProperty;
}
helper 	UML::Element::resolvePIMImplicitPropertyReference(psmContext:UML::Property):UML::Property{

        return self.getNearestNIEMSchemaPackage().getPropertyHolders().ownedAttribute
        ->select(p|p.matchesProperty(psmContext))->asSequence()->first();

}

mapping UML::Property::NIEMRoleOf(inout classifier:UML::Classifier,domainContext:UML::Package):UML::Property@niemUml
	inherits UML::Property::NIEMProperty
	when{self.isRoleOf()}
	{
		name:=result.name.toRoleOfName();
		aggregation:=UML::AggregationKind::none;// force result to be reference
	}
mapping UML::Dependency::NIEMAppliesTo(inout psmAttribute:UML::NamedElement,domainContext:UML::Package):UML::Dependency@niemUml
	{
		client:=psmAttribute;
		psmAttribute.getNearestPackage().packagedElement+=result;
		supplier:=self.supplier.oclAsType(UML::Classifier).getPsmClassifier(domainContext);
	}
mapping UML::Dependency::NIEMMetadataApplication(inout psmClassifier:UML::Property,domainContext:UML::Package):UML::Usage@niemUml
	inherits UML::Dependency::NIEMAppliesTo
	when{self.oclIsKindOf(UML::Usage)
			and self.IsStereotypeApplied(NIEMMetadataApplicationStereotype)
			and self.supplier->exists(s|s.oclIsKindOf(UML::Classifier)or s.oclIsKindOf(UML::Property))}
	{
	result.ApplyStereotype(NIEMMetadataApplicationStereotype);
	}
mapping UML::Property::NIEMProperty(inout classifier:UML::Classifier,domainContext:UML::Package):UML::Property@niemUml
	inherits UML::Property::XSDFeature_init
	{
		var isElement:Boolean=self.isPsmXsdElement();
        name:=result.name;
        if(self.owner.oclAsType(UML::Classifier).isNIEMConformant())then{
                if(isElement)then{
                        name:=result.name.firstToUpper();
                        //  check if association element
                        if(not(self.type.oclIsUndefined())
                        	and (self.type.oclIsKindOf(UML::AssociationClass) 
                        		or self.type.IsStereotypeApplied(NIEMAssociationStereotype)))then{
                        	// make sure association term there
                        	if(result.name.endsWith('Association'))then{}else{
                        			result.name:=result.name+'Association';
                        	}endif;
                        }endif;
                        //  check if metadata element
                        if(not(self.type.oclIsUndefined())
                        	and self.type.isPimMetadata())then{
	                        	// check for metadataApplication
	     						self.clientDependency.map NIEMMetadataApplication(result,domainContext);
	                        	if(result.name.isMetadataName())then{}else{
	                        			result.name:=result.name.toMetadataName();
	                        	}endif;
                        }endif;
						// check if representation element
                        if(self.type.oclIsUndefined()
                        	and self.IsStereotypeApplied(NIEMRepresentationStereotype))then{
	                        	if(result.name.endsWith('Representation'))then{}else{
	                        			result.name:=result.name+'Representation';
	                        	}endif;
                        }endif;
	
                }else{
                        name:=result.name.firstToLower();
                }endif;
        }endif;
        var useSelf:UML::Property=self.toMappingConstraintProperty();
	switch{
		// check if property in <<List>>
		case(self.owner.IsStereotypeApplied(NIEMListTypeStereotype)){}
		case(self.isChoiceProperty()){
			// the type should be nested in the class containing the choice property
                                result.owner.oclAsType(UML::Class).nestedClassifier+=result.type.oclAsType(UML::Class);
			};

		case(useSelf.IsStereotypeApplied(NIEMPropertyStereotype)){
			var stereotypeInstance:Stdlib::Element=useSelf.GetStereotypeApplication(NIEMPropertyStereotype).oclAsType(Stdlib::Element);
			stereotypeInstance.deepcloneStereotypeApplication(NIEMPropertyStereotype,result);
			stereotypeInstance.setNIEMPropertyKind(if(isElement)then 'element' else 'attribute' endif);
			};
		else{
			var stereotypeInstance:Stdlib::Element=result.ApplyStereotype(NIEMPropertyStereotype);
			stereotypeInstance.setNIEMPropertyKind(if(isElement)then 'element' else 'attribute' endif);
			// following do not matter, should be only at top level
			stereotypeInstance.setNIEMPropertyNillable(false);
		};
	};
	isDerivedUnion:=useSelf.isDerivedUnion;
	isDerived:=useSelf.isDerived;
	isReadOnly:=useSelf.isReadOnly;
	subsettedProperty+=self.subsettedProperty.getPsmProperty(domainContext);
	// if this property owned by a non-PropertyHolder, make sure there is a resolved reference
       if(
                not(self.isChoiceProperty())
                and not(self.owner.IsStereotypeApplied(NIEMPropertyHolderStereotype))
                and not(self.owner.IsStereotypeApplied(NIEMListTypeStereotype))
                and not(self.getNearestNIEMSchemaPackage().oclIsUndefined()) // do not resolve for properties outside InformationModel, as in case of SoaML <<MessageType>>
                )then{
		useSelf.resolvePIMPropertyReference(result,domainContext);
		
	}endif;
	}

mapping UML::Generalization::NIEMSimpleContent(inout psmOwner:UML::Classifier,domainContext:UML::Package):UML::Realization@niemUml
	when{
		(self.general.isPimSimplePrimitiveTypeDefinition() and self.specific.isPimComplexTypeSimpleContent())
		or
		(self.specific.oclIsKindOf(UML::Enumeration) and not(self.specific.isPimSimpleTypeDefinition()) and self.general.isPimSimpleTypeDefinition())
		}
	{
		psmOwner.getNearestPackage().packagedElement+=result;
		client+=psmOwner;
		supplier+=self.general.getPsmClassifier(domainContext);
		result.ApplyStereotype(NIEMSimpleContentStereotype);
}
mapping UML::Dependency::XSDSimpleContent(inout psmOwner:UML::Classifier,domainContext:UML::Package):UML::Realization@niemUml
	when{self.IsStereotypeApplied(NIEMSimpleContentStereotype)}
	{
		psmOwner.getNearestPackage().packagedElement+=result;
		client+=psmOwner;
		supplier+=self.supplier.oclAsType(UML::Classifier).getPsmClassifier(domainContext);
		result.ApplyStereotype(NIEMSimpleContentStereotype);
}
mapping UML::Generalization::BaseTypeDefinition(inout psmOwner:UML::Classifier,domainContext:UML::Package):UML::Generalization@niemUml
	when{
		not(self.general.isNiemAugmentationType()  and not(self.specific.isNiemAugmentationType()))
		}
	{
	specific:=psmOwner;
	general:=self.general.getPsmClassifier(domainContext);
}

mapping UML::Generalization::NIEMTopLevel_generalization(inout psmOwner:UML::Classifier,domainContext:UML::Package):UML::Generalization@niemUml
	inherits UML::Generalization::BaseTypeDefinition
	when{
		self.specific.IsStereotypeApplied(NIEMPropertyHolderStereotype)
		and self.general.IsStereotypeApplied(NIEMPropertyHolderStereotype)
		}
{
}
mapping UML::Realization::NIEMRestriction(inout psmOwner:UML::Classifier,domainContext:UML::Package):UML::Realization@niemUml
	when{self.IsStereotypeApplied(NIEMRestrictionStereotype)}
{
		psmOwner.getNearestPackage().packagedElement+=result;
		client+=psmOwner;
		supplier+=self.supplier.oclAsType(UML::Classifier).getPsmClassifier(domainContext);

	result.ApplyStereotype(NIEMRestrictionStereotype);
		if(not(self._mapping.oclIsUndefined()))then{
			var opaqueExpression:UML::OpaqueExpression=new UML::OpaqueExpression@niemUml();
			opaqueExpression.language+=self._mapping.language;
			opaqueExpression.body+=self._mapping.body;
			_mapping:=opaqueExpression;
		}endif;
	
}

mapping UML::Generalization::NIEMSimpleRestriction(inout psmOwner:UML::Classifier,domainContext:UML::Package):UML::Realization@niemUml
	when{
			(self.general.isDerivedFromSimpleType()		
			and (self.specific.isRestricted())
			and not(self.specific.IsStereotypeApplied(NIEMListTypeStereotype))
			)
		}
		
{
		psmOwner.getNearestPackage().packagedElement+=result;
		client+=psmOwner;
		supplier+=self.general.oclAsType(UML::Classifier).getPsmClassifier(domainContext);
	result.ApplyStereotype(NIEMRestrictionStereotype);
}
mapping UML::Generalization::NIEMExtension(inout psmOwner:UML::Classifier,domainContext:UML::Package):UML::Generalization@niemUml
	inherits UML::Generalization::BaseTypeDefinition
	when{self.isExtends()}
{
}


////////////////////////////////////mappings end
////////////////////////////////////start queries
query UML::Element::standardOpeningPhrase(inout psmElement:UML::Element,commentBody:String):String=
	switch{
	case(self.isPimAbstract()) 
		if(commentBody.startsWith('A data concept for a'))then commentBody else commentBody.openingPhrase('A data concept for a ') endif;
	case(self.isPimAssociation())commentBody.openingPhrase('A data type for a relationship ');
	case(self.isPimAssociationElement())commentBody.openingPhrase('A relationship ');
	case(self.isPimAugmentation())commentBody.openingPhrase('A data type that supplements ');
	case(self.isPimAugmentationElement())commentBody.openingPhrase('Supplements ');
	case(self.isPimMetadata())
		if(commentBody.startsWith('A data type for metadata about ') or commentBody.startsWith('A data type for information that further qualifies'))
			then commentBody else commentBody.openingPhrase('A data type for metadata about ')endif;
	case(self.isPimMetadataElement())
		if(commentBody.startsWith('Metadata about ') or commentBody.startsWith('Information that further qualifies'))
		 	then commentBody else commentBody.openingPhrase('Metadata about ') endif;
	
	case(self.isPimIndicator())commentBody.openingPhrase('True if '); //"True if; false otherwise/if"
	case(self.isPimDateRepresentationTerm())commentBody.openingPhrase('A date '); 
	case(self.isPimIDRepresentationTerm())commentBody.openingPhrase('An identifier '); 
	case(self.isPimNameRepresentationTerm())commentBody.openingPhrase('A name of '); 
	case(self.isPimCategoryTextRepresentationTerm())commentBody.openingPhrase('A kind of '); 
	case(self.isPimDescriptionTextRepresentationTerm())commentBody.openingPhrase('A description of '); 
	case(self.isPimType())commentBody.openingPhrase('A data type for ');
	case(psmElement.isPsmEntity() and not(commentBody.startsWith('A ') or commentBody.startsWith('An ')))commentBody.openingPhrase('A ');
	else commentBody;
	};
query UML::Element::isPimDescriptionTextRepresentationTerm():Boolean=false;// 
query UML::Element::isPimCategoryTextRepresentationTerm():Boolean=false;// 
query UML::Element::isPimURIRepresentationTerm():Boolean=false;
query UML::Property::isPimURIRepresentationTerm():Boolean=self.toNiemName().endsWith('URI');
query UML::Element::isPimIDRepresentationTerm():Boolean=false;
query UML::Property::isPimIDRepresentationTerm():Boolean=self.toNiemName().endsWith('ID') or self.isPimURIRepresentationTerm();
query UML::Element::isPimMeasureRepresentationTerm():Boolean=false;
query UML::Property::isPimMeasureRepresentationTerm():Boolean=self.toNiemName().endsWith('Measure');
query UML::Element::isPimTextRepresentationTerm():Boolean=false;
query UML::Property::isPimTextRepresentationTerm():Boolean=self.toNiemName().endsWith('Text');
query UML::Element::isPimQuantityRepresentationTerm():Boolean=false;
query UML::Property::isPimQuantityRepresentationTerm():Boolean=self.toNiemName().endsWith('Quantity');
query UML::Element::isPimNameRepresentationTerm():Boolean=false;
query UML::Property::isPimNameRepresentationTerm():Boolean=self.toNiemName().endsWith('Name');
query UML::Element::isPimCodeRepresentationTerm():Boolean=false;
query UML::Property::isPimCodeRepresentationTerm():Boolean=self.toNiemName().endsWith('Code');
query UML::Element::isPimAmountRepresentationTerm():Boolean=false;
query UML::Property::isPimAmountRepresentationTerm():Boolean=self.toNiemName().endsWith('Amount');
////// isPimDateRepresentationTerm overloaded operation
query UML::Element::isPimDateRepresentationTerm():Boolean=false;
query UML::Property::isPimDateRepresentationTerm():Boolean=self.toNiemName().endsWith('Date');
////// isPimMetadata overloaded operation
query UML::Element::isPimMetadata():Boolean=false;
query UML::Class::isPimMetadata():Boolean=self.IsStereotypeApplied(NIEMMetadataStereotype);
////// isPimMetadataElement overloaded operation
query UML::Element::isPimMetadataElement():Boolean=false;
query UML::Property::isPimMetadataElement():Boolean=self.type.isPimMetadata();
///// isPimAbstract overloaded operation
query UML::Element::isPimAbstract():Boolean=false;
query UML::Classifier::isPimAbstract():Boolean=self.isAbstract;
query UML::Property::isPimAbstract():Boolean=self.type.oclIsUndefined();
////// isPimAssociation overloaded operation
query UML::Element::isPimAssociation():Boolean=false;
query UML::Association::isPimAssociation():Boolean=true;
query UML::Class::isPimAssociation():Boolean=self.IsStereotypeApplied(NIEMAssociationStereotype);
////// isPimAssociationElement overloaded operation
query UML::Element::isPimAssociationElement():Boolean=false;
query UML::Property::isPimAssociationElement():Boolean=self.type.isPimAssociation();
////// isPimAugmentation overloaded operation
query UML::Element::isPimAugmentation():Boolean=false;
query UML::Class::isPimAugmentation():Boolean=self.IsStereotypeApplied(NIEMAugmentationStereotype);
////// isPimAugmentation overloaded operation
query UML::Element::isPimAugmentationElement():Boolean=false;
query UML::Property::isPimAugmentationElement():Boolean=
	(not(self.type.oclIsUndefined()) and self.type.IsStereotypeApplied(NIEMAugmentationStereotype))
	or self.name.endsWith('AugmentationPoint');
query UML::Generalization::isPimAugmentationElement():Boolean=self.general.IsStereotypeApplied(NIEMAugmentationStereotype);
///// isPimRole overloaded operation
query UML::Element::isPimRole():Boolean=false;
query UML::Generalization::isPimRole():Boolean=self.IsStereotypeApplied(NIEMRoleOfStereotype);
query UML::Property::isPimRole():Boolean=self.IsStereotypeApplied(NIEMRoleOfStereotype);
/////// isPimIndicator overloaded operation
query UML::Element::isPimIndicator():Boolean=false;
//query UML::Property::isPimIndicator():Boolean=not(self.type.oclIsUndefined()) and self.type.oclIsKindOf(UML::PrimitiveType) and (self.type.name='Boolean');
// tjd
query UML::Property::isPimIndicator():Boolean=
	not(self.type.oclIsUndefined()) and self.type.oclIsKindOf(UML::PrimitiveType) and (self.type.name.toUpper()='BOOLEAN');
/////// isPimType overloaded operation
query UML::Element::isPimType():Boolean=false;
query UML::Classifier::isPimType():Boolean=true;
////// isPsmEntity overloaded operation
query UML::Element::isPsmEntity():Boolean=false;
query UML::Property::isPsmEntity():Boolean=true;

query String::openingPhrase(startText:String):String{
	var phrase:String=self;
	if(phrase.startsWith(startText))then{}else{phrase:=startText+phrase;}endif;
	return phrase;
}
query UML::Classifier::isPimSimpleTypeDefinition():Boolean=false;
// extended Enumeration simple/complex type target test to include proxy restriction, per Issue 18361: PSM Representation for XSD Complex Type with Simple Content
 
query UML::Enumeration::isPimSimpleTypeDefinition():Boolean{
	if(self.isLeaf)then{return false;}endif;
	if(self.isProxyRestriction())then{return false;}endif;
	if(self.ownedLiteral->isEmpty() and self.general->notEmpty())then {return false;}endif;
	self.getGeneralRestrictions()->forEach(g){return g.isPimSimpleTypeDefinition();};
	return true;
}

query UML::Classifier::isDerivedFromSimpleType():Boolean=
	self.isPimSimplePrimitiveTypeDefinition() 
	or self.IsStereotypeApplied(NIEMListTypeStereotype)
	or self.oclIsKindOf(UML::Enumeration)
	or self.getGeneralRestrictions()->exists(g|g.isDerivedFromSimpleType());
 
query UML::Classifier::isRestricted():Boolean=
	self.IsStereotypeApplied(NIEMSimpleTypeStereotype) 
	or self.IsStereotypeApplied(NIEMRepresentationRestrictionStereotype)
	or self.name.endsWith('Simple')
	or self.name.endsWith('SimpleType')
	or (self.oclIsKindOf(UML::Enumeration) and self.oclAsType(UML::Enumeration).ownedLiteral->notEmpty())
	;
query UML::Classifier::isPimSimplePrimitiveTypeDefinition():Boolean=false;
// if self is an XML Primitive Type or <<Union>> or the general isPimSimplePrimitiveTypeDefinition or the <<Restriction>> is
query UML::PrimitiveType::isPimSimplePrimitiveTypeDefinition():Boolean=
		self.isXmlPrimitive()
		or self.IsStereotypeApplied(NIEMUnionTypeStereotype)
		or self.IsStereotypeApplied(NIEMListTypeStereotype)
		or (
			self.getGeneralRestrictions()->exists(g|g.isPimSimplePrimitiveTypeDefinition())
			and not(self.isProxyRestriction())
			and self.isRestricted()
		);
// if self is a <<ValueRestriction>> or <<List>> or name ends with Simple or SimpleType		
query UML::DataType::isPimSimpleTypeDefinition():Boolean=
	(
		self.isRestricted() 
		and not(self.isLeaf) 
		and self.getGeneralRestrictions()->exists(g|g.isXmlPrimitive() or g.isPimSimpleTypeDefinition())
		and not(self.isProxyRestriction())
		)
	or self.isXmlPrimitive() // Issue 18361* additional check
	or self.IsStereotypeApplied(NIEMListTypeStereotype)
	or self.getGeneralRestrictions()->exists(g|g.isXmlPrimitive() and self.ownedRule->notEmpty())
	or self.name.endsWith('Simple')
	or self.name.endsWith('SimpleType')
	;
query UML::Property::isXsdWildcard():Boolean=
	not( self.IsStereotypeApplied(NIEMPropertyStereotype))
	and(
	(self.type.oclIsUndefined() and not(self.isDerivedUnion))
	or self.IsStereotypeApplied(NIEMAnyPropertyStereotype)
	);
query UML::Property::isPsmXsdElement():Boolean{
	if(self.IsStereotypeApplied(NIEMPropertyStereotype))then{
		return (self.GetStereotypeApplication(NIEMPropertyStereotype).oclAsType(Stdlib::Element).getNIEMPropertyKind()='element');
	}endif;
	return (self.name.firstToUpper()=self.name)
		or self.type.oclIsUndefined()
		or not(self.type.oclAsType(UML::Classifier).isXmlPrimitive());
}
query UML::NamedElement::toNiemName():String=self.name;
query UML::AssociationClass::toNiemName():String=
	self.name.toNIEMAssociationName();
query UML::Classifier::toNiemName():String=
	if(self.IsStereotypeApplied(NIEMAssociationStereotype)) then self.name.toNIEMAssociationName()
	else
		if(self.IsStereotypeApplied(NIEMMetadataStereotype))then  self.name.toNIEMMetadataName()
		else
			if(self.IsStereotypeApplied(NIEMAugmentationStereotype))then  self.name.toNIEMAugmentationName()
			else
				if(self.IsStereotypeApplied(NIEMAdapterStereotype))then  self.name.toNIEMAdapterName()
				else
					if(self.isPimSimpleTypeDefinition())then  self.name.toNIEMSimpleTypeName()
					else
						self.name.toTypeName()
					endif
				endif
			endif
		endif
	endif;

query UML::Property::toNiemName():String=
	if(self.isRoleOf()) then self.name.toRoleOfName()
	else
		self.name.toNCName()
	endif;
query UML::Enumeration::toNiemName():String=
	if(self.isPimSimpleTypeDefinition())then self.name.toNIEMCodeSimpleName()
	else self.name.toNIEMCodeName()
	endif;


query UML::NamedElement::isNameMatch(domainNamedElement:UML::NamedElement):Boolean{
	// context is niem reference model
	return (self.name=domainNamedElement.name)or(self.name=domainNamedElement.toNiemName());
}
// also if name matches an xml primitive even if it is in some other namespace like umlPrimitives or ea java.lang.String
query UML::Classifier::isXmlPrimitive():Boolean=
		(self.owner.oclAsType(UML::NamedElement).name=XMLPrimitiveTypesPackageName) 
		or (self.owner.oclAsType(UML::NamedElement).name=UMLPrimitiveTypesPackageName)
		;
query UML::Classifier::inheritsXmlPrimitive():Boolean=
	self.isXmlPrimitive() or self.getGeneralRestrictions()->exists(g|g.inheritsXmlPrimitive())
		;
query UML::Generalization::isExtends():Boolean=
	not(self.IsStereotypeApplied(NIEMRoleStereotype))
	;
// is a <<References>> , but not between Classifier and non-<<PropertyHolder>>, nor between <<PropertyHolder>>s, nor between Packages		
query UML::Dependency::isValidReference():Boolean=
	self.IsStereotypeApplied(NIEMReferencesStereotype)
	and not(
		self.client->forAll(c|c.oclIsKindOf(UML::Classifier))
		and self.supplier
			->forAll(c|
				c.oclIsKindOf(UML::Classifier)
				and not(c.IsStereotypeApplied(NIEMPropertyHolderStereotype))
				)
	)
	and not(
		self.client->forAll(c|c.IsStereotypeApplied(NIEMPropertyHolderStereotype))
		and self.supplier->forAll(c|c.IsStereotypeApplied(NIEMPropertyHolderStereotype))
	)
	and not(
		self.client->forAll(c|c.oclIsKindOf(UML::Package))
		and self.supplier
			->forAll(c|
				c.oclIsKindOf(UML::Package)
				)
	)
	;
abstract query UML::NamedElement::toPsmNamedElement(domainContext:UML::Package):UML::NamedElement;
query UML::Package::toPsmNamedElement(domainContext:UML::Package):UML::NamedElement=
	self.getPsmPackage(domainContext);
query UML::Classifier::toPsmNamedElement(domainContext:UML::Package):UML::NamedElement=
	self.getPsmClassifier(domainContext);
query UML::Property::toPsmNamedElement(domainContext:UML::Package):UML::NamedElement{
		var psmProperty:UML::Property=self.getPsmProperty(domainContext);
		if(psmProperty.oclIsUndefined())then{log('ERROR: toPsmNamedElement failed to resolve '+self.qualifiedName+', '+domainContext.qualifiedName);}
		else{
			if(not(psmProperty.owner.oclIsKindOf(UML::Classifier)))then{
				log('ERROR: toPsmNamedElement resolved psm Property not owned by classifier '+self.qualifiedName+', '+domainContext.qualifiedName);
			}endif;
		}endif;
		return psmProperty;
	}

query UML::Property::isRoleOf():Boolean=
	self.IsStereotypeApplied(NIEMRoleOfStereotype) or self.name.isRoleOfName();
// returns context (no-op) part of Issue 18251: NIEM-UML Issue: Constraint schema 
query UML::Element::toConstraintProperty():UML::Element{
	var constraintProperty:UML::Element=self;
	return constraintProperty;
	}
// return property defining override in matching constraint schema, otherwise self, part of Issue 18251: NIEM-UML Issue: Constraint schema 	
query UML::Property::toMappingConstraintProperty():UML::Property{
	var constraintProperty:UML::Property=self;
	// if constraint mode, try to find match in constraint model
	if(constraintMode)then{
		// up to <<InformationModel>> to check supplier dependencies; search for class match, then property match
		var myProperty:UML::Property=self;
		var propertyName:String=myProperty.name;
		var className:String=myProperty.owner.oclAsType(UML::NamedElement).name;
		self.getNearestNIEMSchemaPackage().getPimConstraintModels().ownedType
			->select(t|t.name=className).oclAsType(UML::Classifier).attribute
			->select(a|a.name=propertyName)
			->forEach(attribute){
				log('toMappingConstraintProperty '+attribute.qualifiedName+', '+attribute.type.qualifiedName);
				return attribute;
			};
	}endif;
	return constraintProperty;
	}
query UML::Classifier::getOrderedProperties():OrderedSet(UML::Element){
	var orderedProperties:OrderedSet(UML::Element)=switch{
			case(self.oclIsKindOf(UML::AssociationClass))
				self.oclAsType(UML::AssociationClass).ownedEnd
				->union(self.oclAsType(UML::AssociationClass).ownedAttribute).toConstraintProperty()->asOrderedSet();
			case(self.oclIsKindOf(UML::Class))self.oclAsType(UML::Class).ownedAttribute
				->select(p|
					p.association.oclIsUndefined()
					or not(p.association.oclIsKindOf(UML::AssociationClass))
				).toConstraintProperty()->asOrderedSet();
			else self.oclAsType(UML::DataType).ownedAttribute.toConstraintProperty()->asOrderedSet();
	};
	self.getAssociations()->select(a|a.oclIsTypeOf(UML::Association) and not(a.isDerived)).navigableOwnedEnd
		->select(n|n.opposite.type=self)
		->sortedBy(n|n.name)
		->forEach(attribute){
			orderedProperties+=attribute;
		};
	orderedProperties+=self.generalization
	->select(g|
		g.IsStereotypeApplied(NIEMRoleStereotype)

		or (g.general.IsStereotypeApplied(NIEMAugmentationStereotype)and not(self.IsStereotypeApplied(NIEMAugmentationStereotype)))
		or (g.general.IsStereotypeApplied(NIEMMetadataStereotype)and not(self.IsStereotypeApplied(NIEMMetadataStereotype)))
	)->sortedBy(g|g.general.qualifiedName);
	
	return orderedProperties;
}
query UML::Classifier::isNiemAugmentationType():Boolean=
	self.IsStereotypeApplied(NIEMAugmentationStereotype);
query UML::Property::isChoiceProperty():Boolean=not(self.type.oclIsUndefined()) and self.type.IsStereotypeApplied(NIEMChoiceStereotype);
query 	UML::Property::findTopLevelPIMProperty():UML::Property=
        self.getNearestNIEMSchemaPackage().getPropertyHolders().ownedAttribute->select(p|p.matchesProperty(self))->asSequence()->first();
query 	UML::Property::matchesProperty(other:UML::Property):Boolean=
	self.name=other.name;
query 	UML::Package::getPropertyHolders():Sequence(UML::Class)=
	self.ownedType
	->select(t|t.IsStereotypeApplied(NIEMPropertyHolderStereotype)).oclAsType(UML::Class)
	->asSequence();

query 	UML::Property::getResolvedProperty():UML::Property{
	// via Reference, if it exists; otherwise self
	var referencedTopLevelProperty:UML::Property=
		self.clientDependency
		->select(r|r.isValidReference()).supplier
		->select(t|t.oclIsKindOf(UML::Property) 
			and t.namespace.IsStereotypeApplied(NIEMPropertyHolderStereotype)
			)
		.oclAsType(UML::Property)
		->asSequence()->first();
		// if no <<PropertyHolder>> found, then try <<References>> to a Classifier Property
	if(referencedTopLevelProperty.oclIsUndefined())then{
		// see if we can indirectly resolve via non-<<PropertyHolder>>
		referencedTopLevelProperty:=
			self.clientDependency
			->select(r|r.isValidReference()).supplier
			->select(t|t.oclIsKindOf(UML::Property) 
				// make sure not a subsetting <<References>>
				and not(self.isSubbsettingReference(t))
				)
			.oclAsType(UML::Property)
			->asSequence()->first();
		}endif;
	if(referencedTopLevelProperty.oclIsUndefined())then{
		// see if we can indirectly resolve via non-<<PropertyHolder>>
		referencedTopLevelProperty:=self;
		}endif;
	return referencedTopLevelProperty;
}
query 	UML::NamedElement::isSubbsettingReference(reference:UML::NamedElement):Boolean{
	if(reference.oclIsUndefined())then {return false;}endif;
	var selfInformationModel:UML::Package=self.getNearestNIEMSchemaPackage();
	var referenceInformationModel:UML::Package=reference.getNearestNIEMSchemaPackage();
	if(selfInformationModel=referenceInformationModel)then{return false;}endif;
	if(selfInformationModel.oclIsUndefined() or referenceInformationModel.oclIsUndefined())then {return false;}endif;
	return selfInformationModel.getSchemaTargetNamespace()=referenceInformationModel.getSchemaTargetNamespace();
}
query 	UML::Property::getCascadedResolvedProperty():UML::Property=
	// try via Reference at Class level
	self.owner.oclAsType(UML::NamedElement).clientDependency
		->select(r|r.isValidReference()).supplier
		->select(t|
			t.oclIsKindOf(UML::Class)
			and t.IsStereotypeApplied(NIEMPropertyHolderStereotype)
		)
		.oclAsType(UML::Class).ownedAttribute
		->select(p|p.matchesProperty(self))
		->asSequence()->first();

query String::toCharSet(charSet:String):String=self.normalizeSpace();
/////////////////////////////helpers
helper  UML::Property::getPsmProperty(domainContext:UML::Package):UML::Property{
            var myPackage:UML::Package=self.getNearestNIEMSchemaPackage();
			var newDomainContext:UML::Package=myPackage.getPimDomainContext(domainContext);
			var useSelf:UML::Property=self;
			var useType:UML::Classifier=self.owner.oclAsType(UML::Classifier);
			if(newDomainContext<>domainContext)then{
				newDomainContext.ownedType->select(t|useType.isNameMatch(t))
				.oclAsType(UML::Classifier).attribute->select(a|self.isNameMatch(a))
				->forEach(domainProperty){
					useSelf:=domainProperty.oclAsType(UML::Property);
				};
			}endif;
	var psmClassifier:UML::Classifier=useSelf.owner.oclAsType(UML::Classifier).getPsmClassifier(newDomainContext);
	return useSelf.toConstraintProperty().map AbstractXSDFeature(psmClassifier,newDomainContext);
	}
helper UML::Classifier::getPsmClassifier(domainContext:UML::Package):UML::Classifier{
	if(self.isXmlPrimitive())then {return self;}
		else {
            var myPackage:UML::Package=self.getNearestNIEMSchemaPackage();
			var newDomainContext:UML::Package=myPackage.getPimDomainContext(domainContext);
			var useSelf:UML::Classifier=self.getPimClassifier(domainContext);
            
			// if self is in a pim constraint <<InformationModel>>, then we need to find corresponding base schema Classifier
			// this should be known via <<References>> at <<InformationModel>> plus scan for matching Classifier name
			// this extra test should only be needed in constraintMode
			if(constraintMode and myPackage.isConstraintModel())then{
				
				// and now we end up with 2 Properties that are the same?
				// maybe we should just not do subsetsProperty in constraintMode? TODO ---------------------
				// we need to change when we get constraint Property info to the mapping, not before
				myPackage:=myPackage.getPimConstrainedModel();
				newDomainContext:=myPackage;
				useSelf:=myPackage.ownedType
					->select(t|t.oclIsKindOf(Classifier)).oclAsType(Classifier)->select(t|t.name=self.name)
					->asSequence()
					->first().getPimClassifier(newDomainContext);
			}endif;
			var pimOwner:UML::Element=useSelf.owner;
			if(pimOwner.oclIsKindOf(UML::Package))then{
				var psmPackage:UML::Package=pimOwner.oclAsType(UML::Package).getPsmPackage(newDomainContext);
				return useSelf.map AbstractXSDTypeDefinition(psmPackage,newDomainContext);
			}else{
				var psmClass:UML::Classifier=pimOwner.oclAsType(UML::Class).getPsmClassifier(newDomainContext);
				return useSelf.map AbstractXSDTypeDefinition(psmClass,newDomainContext);
			}endif;
		} endif;
}
helper UML::Classifier::getPimClassifier(domainContext:UML::Package):UML::Classifier{
	if(self.isXmlPrimitive())then {return self;}
		else {

            var myPackage:UML::Package=self.getNearestNIEMSchemaPackage();
			var newDomainContext:UML::Package=myPackage.getPimDomainContext(domainContext);
			var useSelf:UML::Classifier=self;
			if((newDomainContext<>domainContext)or(newDomainContext<>myPackage))then{
				newDomainContext.ownedType->select(t|self.isNameMatch(t))
				->forEach(domainType){
					useSelf:=domainType.oclAsType(UML::Classifier);
					};
			}endif;
			return useSelf;
		} endif;
}
// get the PIM package to be used in the context of domainContext
// by default, this will be self
// in the case that self is a reference model and the context has a Usage with a subset of that reference,
//		then return that subset
// this allows references from the domainContext to a reference model to be changed to references to a subset model
helper UML::Package::getPimDomainContext(domainContext:UML::Package):UML::Package{
	// if self is not domainContext or a realization of domainContext then change domainContext to be self or a usage from domainContext which realizes self
	//  in that case, also change use of self
	var useDomainContext:UML::Package=domainContext;
	var useSelf:UML::Package=self;
	if((self<>useDomainContext) and not(useDomainContext.getReferences()->includes(self)))then{
		useDomainContext:=useSelf;
		domainContext.getUsages()
		->select(s|
				(s=self)
				or s.getReferences()->includes(self)
				)
		->forEach(domainContextTest){
			useDomainContext:=domainContextTest.oclAsType(UML::Package);
		};
	}endif;
	return useDomainContext;
}
helper UML::NamedElement::getReferences():Set(UML::NamedElement)=
		self.clientDependency->select(d|d.IsStereotypeApplied(NIEMReferencesStereotype)).supplier->asSet();
helper UML::NamedElement::getUsages():Set(UML::NamedElement)=
		self.clientDependency->select(d|d.oclIsKindOf(UML::Usage)).supplier->asSet();


helper UML::Package::getPsmPackage(domainContext:UML::Package):UML::Package{
	// if this is top level package, result is mpdPackage; otherwise map to parent
	if(self.isProfileApplied(structureProfile)
		or self.isProfileApplied(provisioningProfile)
		or (not(self.isEditable()) and not(self.IsStereotypeApplied(NIEMSchemaStereotype)) and self.isNiemReferenceModel())
		or (self=psmModel)
		or(self.nestingPackage.oclIsUndefined())
		)then
		{
			// expand reference models up to niem level
			if(self.isNiemReferenceModel())then{
				return self.getNiemReferenceModelPackage();
			}endif;
			return psmModel;
		}
	endif;
	// if self is not domainContext  then change domainContext to be self or a usage from domainContext which realizes self
	//  in that case, also change use of self
	var useDomainContext:UML::Package=domainContext;
	var useSelf:UML::Package=self;
	if((self<>useDomainContext) and not(useDomainContext.getReferences()->includes(self)))then{
		useDomainContext:=useSelf;
		domainContext.getUsages()
		->select(s|
				(s=self)
				or s.getReferences()->includes(self)
				)
		->forEach(domainContextTest){
			useDomainContext:=domainContextTest.oclAsType(UML::Package);
			useSelf:=useDomainContext;
		};
	}else{
		if((self<>useDomainContext))then{
			useSelf:=domainContext;
		}endif;
	}endif;

	var nestingPsmPackage:UML::Package=useSelf.nestingPackage.getPsmPackage(useDomainContext);
	return useSelf.map AbstractPackage(nestingPsmPackage,useDomainContext);
}

helper UML::Package::isNiemReferenceModel():Boolean{
	// if this is top level package, result is mpdPackage; otherwise map to parent
	if('niem'=self.name)then
		{
		// check if this is top level
		if(not(self.nestingPackage.oclIsUndefined()) and self.nestingPackage.nestingPackage.oclIsUndefined())then{
			return true;
		}endif;
		return false;
		}
	endif;
	if(self.nestingPackage.oclIsUndefined())then
		{
		return false;
		}
	endif;
	return self.nestingPackage.isNiemReferenceModel();
}
helper UML::Package::getNiemReferenceModelPackage():UML::Package{
	// if this is top level package, result is mpdPackage; otherwise map to parent
	if('niem'=self.name)then
		{
			// expand reference models up to niem level
		return self.map AbstractPackage(psmModel,self);
		}
	endif;
	var nestingPsmPackage:UML::Package=self.nestingPackage.getNiemReferenceModelPackage();
	return self.map AbstractPackage(nestingPsmPackage,self);
}
helper UML::Package::getConstraintPackage():UML::Package{
	// should be XMLschemas::constraint
	var topLevel:Package=self;
	// if it does not already exist, make it
	var constraintPackage:Package=topLevel.nestedPackage->select(p|p.name=CONSTRAINT_XSD_NAME)->asSequence()->first();
	if(constraintPackage.oclIsUndefined())then{
		constraintPackage:=new Package();
		constraintPackage.name:=CONSTRAINT_XSD_NAME;
		topLevel.packagedElement+=constraintPackage;
	}endif;
	return constraintPackage;
}

helper 	UML::Property::resolvePIMPropertyReference(psmContext:UML::Property,domainContext:UML::Package):UML::Property{
	// via Reference, if it exists; otherwise self
	var referencedPIMTopLevelProperty:UML::Property=self.getResolvedProperty();
	if(self<>referencedPIMTopLevelProperty)then{
		return referencedPIMTopLevelProperty;
	}endif;
	// top level not referenced directly
	// check for cascaded reference via class or package

	referencedPIMTopLevelProperty:=self.getCascadedResolvedProperty();
	if(referencedPIMTopLevelProperty.oclIsUndefined())then{
		referencedPIMTopLevelProperty:=self.findTopLevelPIMProperty();
	}endif;
	// need to create or find a top level matching property within this schema
	var referencedPSMTopLevelProperty:UML::Property=referencedPIMTopLevelProperty.getPsmProperty(domainContext);

	if(referencedPSMTopLevelProperty.oclIsUndefined())then{
		// no such property, need to create one
		referencedPSMTopLevelProperty:=self.makeTopLevelPSMProperty(psmContext,domainContext);
	}endif;
	
	// add a reference to the top level property
	var reference:UML::Realization=new UML::Realization@niemUml();

	psmContext.getNearestPackage().packagedElement+=reference;
	reference.client+=psmContext;
	reference.supplier+=referencedPSMTopLevelProperty;
	reference.ApplyStereotype(NIEMReferencesStereotype);

	return referencedPIMTopLevelProperty;
}
helper 	UML::Property::makeTopLevelPSMProperty(psmContext:UML::Property,domainContext:UML::Package):UML::Property{
	var propertyName:String=psmContext.name;

	// check if property already defined
	psmContext.getNearestNIEMSchemaPackage().getPropertyHolders().attribute->select(p|p.name=propertyName)
	->forEach(existingProperty){
		return existingProperty;
	};

     var psmHolder:UML::Class=psmContext.getNearestNIEMSchemaPackage().getTopLevelPsmPropertyHolder();
	var psmProperty:UML::Property=new UML::Property@niemUml();
	psmHolder.ownedAttribute+=psmProperty;
		var isElement:Boolean=self.isPsmXsdElement();

	switch{
		case(self.IsStereotypeApplied(NIEMPropertyStereotype))
			self.GetStereotypeApplication(NIEMPropertyStereotype).oclAsType(Stdlib::Element).deepcloneStereotypeApplication(NIEMPropertyStereotype,psmProperty);
		else{
			var stereotypeInstance:Stdlib::Element=psmProperty.ApplyStereotype(NIEMPropertyStereotype);
			stereotypeInstance.setNIEMPropertyKind(if(isElement)then 'element' else 'attribute' endif);
			stereotypeInstance.setNIEMPropertyNillable(false);
		};
	};
	psmProperty.subsettedProperty+=self.subsettedProperty.getPsmProperty(domainContext);

	var attr:UML::Property=self;
	psmProperty.name:=propertyName;
	psmProperty.isDerived:=attr.isDerived;
	psmProperty.isReadOnly:=attr.isReadOnly;
	psmProperty.setLower(attr.lower);
	psmProperty.setUpper(attr.upper);

	psmProperty.isOrdered:=attr.isOrdered;
	psmProperty.isUnique:=attr.isUnique;
	psmProperty.aggregation:=attr.aggregation;
	psmProperty.type:=attr.getConstraintPropertyType().oclAsType(UML::Classifier).getPsmClassifier(domainContext);
	self.getPimComment()
	.body->forEach(body){
		var comment:UML::Comment=new UML::Comment@niemUml();
		psmProperty.ownedComment+=comment;
		comment.annotatedElement+=psmProperty;
		comment.body:=body;
		comment.ApplyStereotype(NIEMDescriptionStereotype);
	};
	return psmProperty;
}
helper 	UML::Package::getTopLevelPsmPropertyHolder():UML::Class{
	var psmPropertyHolder:UML::Class=self.getPropertyHolders()->first();
	if(psmPropertyHolder.oclIsUndefined())then{
		psmPropertyHolder:=self.makeTopLevelPSMPropertyHolder();
	}endif;
	return psmPropertyHolder;
}
helper 	UML::Package::makeTopLevelPSMPropertyHolder():UML::Class{
	var psmPropertyHolder:UML::Class=new UML::Class@niemUml();
	var psmSchema:UML::Package=self;
	psmPropertyHolder.name:='topLevelProperties';
	psmSchema.packagedElement+=psmPropertyHolder;
	psmPropertyHolder.ApplyStereotype(NIEMPropertyHolderStereotype);
	return psmPropertyHolder;
}
//////////////////////////Naming
query String::toTypeName():String=self.toUnsimpleName()+'Type';

query String::toUntypedName():String{
	var untypedName:String=self;
	if(untypedName.isTypeName())then{untypedName:=untypedName.substring(1,untypedName.size()-4);}else{}endif;
	return untypedName;
}
query String::isTypeName():Boolean=self.endsWith('Type');
query String::firstToLower():String=self.substring(1,1).toLower()+self.substring(2,self.size());
query String::toUnaugmentationName():String{
	var untypedName:String=self.toUntypedName();
	if(untypedName.isAugmentationName())then{untypedName:=untypedName.substring(1,untypedName.size()-12);}else{}endif;
	return untypedName;
}
query String::isAugmentationName():Boolean=self.endsWith('Augmentation');
query String::toAugmentationName():String=self.toUnaugmentationName()+'Augmentation';
query String::isMetadataName():Boolean=self.endsWith('Metadata');
query String::toUnmetadataName():String{
	var untypedName:String=self.toUntypedName();
	if(untypedName.isMetadataName())then{untypedName:=untypedName.substring(1,untypedName.size()-8);}else{}endif;
	return untypedName;
}
query String::toMetadataName():String=self.toUnmetadataName()+'Metadata';
query String::toUnadapterName():String{
	var untypedName:String=self.toUntypedName();
	return untypedName;
}
query String::toAdapterName():String=self.toUnadapterName();
query String::isAssociationName():Boolean=self.endsWith('Association');
query UML::Property::isAugmentationPoint():Boolean=not(self.name.oclIsUndefined())and self.name.endsWith('AugmentationPoint');

query String::toUnassociationName():String{
	var untypedName:String=self.toUntypedName();
	if(untypedName.isAssociationName())then{untypedName:=untypedName.substring(1,untypedName.size()-11);}else{}endif;
	return untypedName;
}
query String::toAssociationName():String=self.toUnassociationName()+'Association';
query String::isSimpleName():Boolean=self.endsWith('Simple');

query String::toUnsimpleName():String{
	var untypedName:String=self.toUntypedName();
	if(untypedName.isSimpleName())then{untypedName:=untypedName.substring(1,untypedName.size()-6);}else{}endif;
	return untypedName;
}
query String::isCodeName():Boolean=self.endsWith('Code');

query String::toUncodeName():String{
	var untypedName:String=self.toUntypedName();
	if(untypedName.isCodeName())then{untypedName:=untypedName.substring(1,untypedName.size()-4);}else{}endif;
	return untypedName;
}
query String::toUncodesimpleName():String{
	var untypedName:String=self.toUnsimpleName();
	if(untypedName.isCodeName())then{untypedName:=untypedName.substring(1,untypedName.size()-4);}else{}endif;
	return untypedName;
}
query String::toSimpleName():String=self.toUnsimpleName()+'Simple';
query String::toCodeName():String=self.toUncodesimpleName()+'Code';

query String::toCodeSimpleName():String=self.toUncodesimpleName()+'Code';

query String::toNIEMAssociationName():String=self.toAssociationName()+'Type';
query String::toNIEMAugmentationName():String=self.toAugmentationName()+'Type';
query String::toNIEMAdapterName():String=self.toAdapterName()+'Type';
query String::toNIEMMetadataName():String=self.toMetadataName()+'Type';
query String::toNIEMSimpleTypeName():String=self.toSimpleName()+'Type';
query String::toNIEMCodeName():String=self.toCodeName()+'Type';
query String::toNIEMCodeSimpleName():String=self.toCodeSimpleName()+'SimpleType';
query String::toRoleOfName():String{
	var referenceName:String=self;
	if(referenceName.isRoleOfName())then{}else{referenceName:='RoleOf'+referenceName;}endif;
	return referenceName;
}
// for given Classifier context, return base types specified via Generalization or <<Restriction>>, refined per Issue 18361: PSM Representation for XSD Complex Type with Simple Content 
query UML::Classifier::getGeneralRestrictions():Set(UML::Classifier)=
	self.generalization->select(g|g.isExtends()).general
	
	->union(
		self.getRestrictions()
		.supplier->select(s|s.oclIsKindOf(UML::Classifier))
		.oclAsType(UML::Classifier)
		)->asSet();
		
// boolean hasPimConstraints, and check schema-set for any type overrides
// make sure that reference types are used at schema-set level, but not constraint level	
query UML::Package::hasPimConstraints():Boolean{
	// check all schemas which are subsetting, each classifier, each property for a type override
	self.ownedType
			->select(t|t.oclIsKindOf(UML::Classifier)).oclAsType(UML::Classifier).attribute
               	->select(a|
               		not(a.type.oclIsUndefined()) 
               		and a.type.oclIsKindOf(UML::Classifier)
               		)->forEach(attribute){
               if(attribute.isConstraintOverride())then{
               		log('subsetting type override at '+attribute.qualifiedName+' will result in constraint-schema-set');
               		return true; 	
               }endif;		
			};
	return false;
}
query UML::Property::getConstraintPropertyType():UML::Type{
	var subsetType:UML::Type=self.type;
	if(not(constraintMode) and self.isConstraintOverride())then{
		// use type equivalent for original reference model;
		// this must be a base of type override on property 
		var subsettedProperty:UML::Property=self.findSubsettedProperty();
		if(not(subsettedProperty.oclIsUndefined()))then {
			var subsettedType:UML::Type=subsettedProperty.type;
			if(subsettedType.oclIsUndefined() or subsetType.oclIsUndefined())then{
				return subsetType;
			}endif;
			return subsetType.findEquivalentReferenceType(subsettedType);
		}endif;
	}endif;
	return subsetType;
}
query UML::Type::findEquivalentReferenceType(subsettedType:UML::Type):UML::Type{
	if(self.isEquivalent(subsettedType) or not(self.oclIsKindOf(UML::Classifier)))then{return self;}endif;
	var baseType:UML::Type=self.oclAsType(UML::Classifier).getBaseType();
	if(baseType.oclIsUndefined())then{return self;}endif;
	return baseType.findEquivalentReferenceType(subsettedType);
}	

query UML::Classifier::getBaseType():UML::Type{
	self.getGeneralRestrictions()->forEach(base){return base;};
	return null;
}	
query UML::Property::isConstraintOverride():Boolean{
	// if in a subsetting model, has subsetted property, and types not equivalent
	var subsettedProperty:UML::Property=self.findSubsettedProperty();
	if(subsettedProperty.oclIsUndefined())then {return false;}endif;
	var subsetType:UML::Type=self.type;
	var subsettedType:UML::Type=subsettedProperty.type;
	if(subsettedType.oclIsUndefined())then{
		return not(subsetType.oclIsUndefined());
	}else{
		if(subsetType.oclIsUndefined())then{
			return true;
		}endif;
	}endif;
	return not(subsetType.isEquivalent(subsettedType));
}	
query UML::Type::isEquivalent(subsettedType:UML::Type):Boolean{
	if(self=subsettedType)then{return true;}endif;
	var overrideType:UML::Type=self.findSubsettedType();
	return (overrideType=subsettedType);
}	
query UML::Property::findSubsettedProperty():UML::Property{
	// try via <<references>> from type; else get subsetted package and search for match
	self.getReferences()
		->select(r|r.oclIsKindOf(UML::Property) and self.isSubbsettingReference(r)).oclAsType(UML::Property)
		->forEach(referenceProperty){return referenceProperty;};
	self.owner->select(t|t.oclIsKindOf(UML::Classifier)).oclAsType(UML::Classifier).findSubsettedType().attribute
		->select(t|t.isNameMatch(self))	
		->forEach(referenceType){return referenceType;};
	return null;	
}	
query UML::Type::findSubsettedType():UML::Classifier{
	// try via <<references>> from type; else get subsetted package and search for match
	self.getReferences()
		->select(r|r.oclIsKindOf(UML::Classifier) and self.isSubbsettingReference(r)).oclAsType(UML::Classifier)
		->forEach(referenceType){return referenceType;};
	self.getNearestNIEMSchemaPackage().findSubsettedModel().ownedType
		->select(t|t.oclIsKindOf(UML::Classifier) and t.isNameMatch(self)).oclAsType(UML::Classifier)	
		->forEach(referenceType){return referenceType;};
	return null;	
}	
query UML::Package::findSubsettedModel():UML::Package{
	// try via <<references>> from type; else get subsetted package and search for match
	self.getReferences()
		->select(r|r.oclIsKindOf(UML::Package) and self.isSubbsettingReference(r)).oclAsType(UML::Package)
		->forEach(referencePackage){return referencePackage;};
	return null;	
}	
query UML::Package::getPimConstraintModels():Set(UML::Package)=
	self.supplierDependency->select(d|d.IsStereotypeApplied(NIEMReferencesStereotype)).client
		->select(c|c.oclIsKindOf(Package)).oclAsType(Package)
		->select(c|c.isConstraintModel())
		->asSet();
query UML::Package::getPimConstrainedModel():UML::Package=
	self.clientDependency->select(d|d.IsStereotypeApplied(NIEMReferencesStereotype)).supplier
		->select(c|c.oclIsKindOf(Package)).oclAsType(Package)
		->asSequence()
		->first();
query UML::Package::isConstraintModel():Boolean=
	self.IsStereotypeApplied(NIEMInformationModelStereotype)
	and self.GetStereotypeApplication(NIEMInformationModelStereotype).oclAsType(Stdlib::Element).getInformationModelDefaultPurpose()='constraint'
	;
query UML::InstanceSpecification::getPimInformationModels():Set(UML::Package)=
	self.clientDependency->select(d|d.oclIsKindOf(UML::Usage)).supplier->select(p|p.oclIsKindOf(UML::Package))
		->select(c|c.IsStereotypeApplied(NIEMInformationModelStereotype))
		.oclAsType(UML::Package)
		->asSet();
// query returns true if Classifier represents ComplexType with Simple Content per Issue 18361: PSM Representation for XSD Complex Type with Simple Content 
query UML::Classifier::isPimComplexTypeSimpleContent():Boolean{
	// if tagged as a ComplexType with Simple Content extending a niem proxy
	if(self.isLeaf)then{return true;}endif;
	// if restriction tagged as restricting a niem proxy
	if(self.isProxyRestriction())then{return true;}endif;
	// if extension is not a SimpleTypeDefinition
	if(self.general->select(r|not(r.isPimSimpleTypeDefinition()))->size()=1) then{return true;}endif;
	// check if this is not a simpleTypeDefinition and there is any general 
	if(not(self.isPimSimpleTypeDefinition()) and self.general->notEmpty())then{return true;}endif;
	// if restriction is a ComplexType with simple content
	self.getRestrictions()
		.supplier->select(s|s.oclIsKindOf(UML::Classifier))
		.oclAsType(UML::Classifier)
		->forEach(restriction){return restriction.isPimComplexTypeSimpleContent()
				or not(restriction.isPimSimpleTypeDefinition()) // TODO:  tjd added check
		;};	
	return false;
}
		